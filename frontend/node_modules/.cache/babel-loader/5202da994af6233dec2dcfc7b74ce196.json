{"ast":null,"code":"import { ElementType } from \"domelementtype\";\nimport { Element, Text, Comment, CDATA, Document, ProcessingInstruction } from \"./node.js\";\nexport * from \"./node.js\";\n// Default options\nconst defaultOpts = {\n  withStartIndices: false,\n  withEndIndices: false,\n  xmlMode: false\n};\nexport class DomHandler {\n  /**\r\n   * @param callback Called once parsing has completed.\r\n   * @param options Settings for the handler.\r\n   * @param elementCB Callback whenever a tag is closed.\r\n   */\n  constructor(callback, options, elementCB) {\n    /** The elements of the DOM */\n    this.dom = [];\n    /** The root element for the DOM */\n    this.root = new Document(this.dom);\n    /** Indicated whether parsing has been completed. */\n    this.done = false;\n    /** Stack of open tags. */\n    this.tagStack = [this.root];\n    /** A data node that is still being written to. */\n    this.lastNode = null;\n    /** Reference to the parser instance. Used for location information. */\n    this.parser = null;\n    // Make it possible to skip arguments, for backwards-compatibility\n    if (typeof options === \"function\") {\n      elementCB = options;\n      options = defaultOpts;\n    }\n    if (typeof callback === \"object\") {\n      options = callback;\n      callback = undefined;\n    }\n    this.callback = callback !== null && callback !== void 0 ? callback : null;\n    this.options = options !== null && options !== void 0 ? options : defaultOpts;\n    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n  }\n  onparserinit(parser) {\n    this.parser = parser;\n  }\n  // Resets the handler back to starting state\n  onreset() {\n    this.dom = [];\n    this.root = new Document(this.dom);\n    this.done = false;\n    this.tagStack = [this.root];\n    this.lastNode = null;\n    this.parser = null;\n  }\n  // Signals the handler that parsing is done\n  onend() {\n    if (this.done) return;\n    this.done = true;\n    this.parser = null;\n    this.handleCallback(null);\n  }\n  onerror(error) {\n    this.handleCallback(error);\n  }\n  onclosetag() {\n    this.lastNode = null;\n    const elem = this.tagStack.pop();\n    if (this.options.withEndIndices) {\n      elem.endIndex = this.parser.endIndex;\n    }\n    if (this.elementCB) this.elementCB(elem);\n  }\n  onopentag(name, attribs) {\n    const type = this.options.xmlMode ? ElementType.Tag : undefined;\n    const element = new Element(name, attribs, undefined, type);\n    this.addNode(element);\n    this.tagStack.push(element);\n  }\n  ontext(data) {\n    const {\n      lastNode\n    } = this;\n    if (lastNode && lastNode.type === ElementType.Text) {\n      lastNode.data += data;\n      if (this.options.withEndIndices) {\n        lastNode.endIndex = this.parser.endIndex;\n      }\n    } else {\n      const node = new Text(data);\n      this.addNode(node);\n      this.lastNode = node;\n    }\n  }\n  oncomment(data) {\n    if (this.lastNode && this.lastNode.type === ElementType.Comment) {\n      this.lastNode.data += data;\n      return;\n    }\n    const node = new Comment(data);\n    this.addNode(node);\n    this.lastNode = node;\n  }\n  oncommentend() {\n    this.lastNode = null;\n  }\n  oncdatastart() {\n    const text = new Text(\"\");\n    const node = new CDATA([text]);\n    this.addNode(node);\n    text.parent = node;\n    this.lastNode = text;\n  }\n  oncdataend() {\n    this.lastNode = null;\n  }\n  onprocessinginstruction(name, data) {\n    const node = new ProcessingInstruction(name, data);\n    this.addNode(node);\n  }\n  handleCallback(error) {\n    if (typeof this.callback === \"function\") {\n      this.callback(error, this.dom);\n    } else if (error) {\n      throw error;\n    }\n  }\n  addNode(node) {\n    const parent = this.tagStack[this.tagStack.length - 1];\n    const previousSibling = parent.children[parent.children.length - 1];\n    if (this.options.withStartIndices) {\n      node.startIndex = this.parser.startIndex;\n    }\n    if (this.options.withEndIndices) {\n      node.endIndex = this.parser.endIndex;\n    }\n    parent.children.push(node);\n    if (previousSibling) {\n      node.prev = previousSibling;\n      previousSibling.next = node;\n    }\n    node.parent = parent;\n    this.lastNode = null;\n  }\n}\nexport default DomHandler;","map":{"version":3,"names":["ElementType","Element","Text","Comment","CDATA","Document","ProcessingInstruction","defaultOpts","withStartIndices","withEndIndices","xmlMode","DomHandler","constructor","callback","options","elementCB","dom","root","done","tagStack","lastNode","parser","undefined","onparserinit","onreset","onend","handleCallback","onerror","error","onclosetag","elem","pop","endIndex","onopentag","name","attribs","type","Tag","element","addNode","push","ontext","data","node","oncomment","oncommentend","oncdatastart","text","parent","oncdataend","onprocessinginstruction","length","previousSibling","children","startIndex","prev","next"],"sources":["D:/Work/V-Book/project/V-Book-Project/frontend/node_modules/domhandler/lib/esm/index.js"],"sourcesContent":["import { ElementType } from \"domelementtype\";\r\nimport { Element, Text, Comment, CDATA, Document, ProcessingInstruction, } from \"./node.js\";\r\nexport * from \"./node.js\";\r\n// Default options\r\nconst defaultOpts = {\r\n    withStartIndices: false,\r\n    withEndIndices: false,\r\n    xmlMode: false,\r\n};\r\nexport class DomHandler {\r\n    /**\r\n     * @param callback Called once parsing has completed.\r\n     * @param options Settings for the handler.\r\n     * @param elementCB Callback whenever a tag is closed.\r\n     */\r\n    constructor(callback, options, elementCB) {\r\n        /** The elements of the DOM */\r\n        this.dom = [];\r\n        /** The root element for the DOM */\r\n        this.root = new Document(this.dom);\r\n        /** Indicated whether parsing has been completed. */\r\n        this.done = false;\r\n        /** Stack of open tags. */\r\n        this.tagStack = [this.root];\r\n        /** A data node that is still being written to. */\r\n        this.lastNode = null;\r\n        /** Reference to the parser instance. Used for location information. */\r\n        this.parser = null;\r\n        // Make it possible to skip arguments, for backwards-compatibility\r\n        if (typeof options === \"function\") {\r\n            elementCB = options;\r\n            options = defaultOpts;\r\n        }\r\n        if (typeof callback === \"object\") {\r\n            options = callback;\r\n            callback = undefined;\r\n        }\r\n        this.callback = callback !== null && callback !== void 0 ? callback : null;\r\n        this.options = options !== null && options !== void 0 ? options : defaultOpts;\r\n        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\r\n    }\r\n    onparserinit(parser) {\r\n        this.parser = parser;\r\n    }\r\n    // Resets the handler back to starting state\r\n    onreset() {\r\n        this.dom = [];\r\n        this.root = new Document(this.dom);\r\n        this.done = false;\r\n        this.tagStack = [this.root];\r\n        this.lastNode = null;\r\n        this.parser = null;\r\n    }\r\n    // Signals the handler that parsing is done\r\n    onend() {\r\n        if (this.done)\r\n            return;\r\n        this.done = true;\r\n        this.parser = null;\r\n        this.handleCallback(null);\r\n    }\r\n    onerror(error) {\r\n        this.handleCallback(error);\r\n    }\r\n    onclosetag() {\r\n        this.lastNode = null;\r\n        const elem = this.tagStack.pop();\r\n        if (this.options.withEndIndices) {\r\n            elem.endIndex = this.parser.endIndex;\r\n        }\r\n        if (this.elementCB)\r\n            this.elementCB(elem);\r\n    }\r\n    onopentag(name, attribs) {\r\n        const type = this.options.xmlMode ? ElementType.Tag : undefined;\r\n        const element = new Element(name, attribs, undefined, type);\r\n        this.addNode(element);\r\n        this.tagStack.push(element);\r\n    }\r\n    ontext(data) {\r\n        const { lastNode } = this;\r\n        if (lastNode && lastNode.type === ElementType.Text) {\r\n            lastNode.data += data;\r\n            if (this.options.withEndIndices) {\r\n                lastNode.endIndex = this.parser.endIndex;\r\n            }\r\n        }\r\n        else {\r\n            const node = new Text(data);\r\n            this.addNode(node);\r\n            this.lastNode = node;\r\n        }\r\n    }\r\n    oncomment(data) {\r\n        if (this.lastNode && this.lastNode.type === ElementType.Comment) {\r\n            this.lastNode.data += data;\r\n            return;\r\n        }\r\n        const node = new Comment(data);\r\n        this.addNode(node);\r\n        this.lastNode = node;\r\n    }\r\n    oncommentend() {\r\n        this.lastNode = null;\r\n    }\r\n    oncdatastart() {\r\n        const text = new Text(\"\");\r\n        const node = new CDATA([text]);\r\n        this.addNode(node);\r\n        text.parent = node;\r\n        this.lastNode = text;\r\n    }\r\n    oncdataend() {\r\n        this.lastNode = null;\r\n    }\r\n    onprocessinginstruction(name, data) {\r\n        const node = new ProcessingInstruction(name, data);\r\n        this.addNode(node);\r\n    }\r\n    handleCallback(error) {\r\n        if (typeof this.callback === \"function\") {\r\n            this.callback(error, this.dom);\r\n        }\r\n        else if (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    addNode(node) {\r\n        const parent = this.tagStack[this.tagStack.length - 1];\r\n        const previousSibling = parent.children[parent.children.length - 1];\r\n        if (this.options.withStartIndices) {\r\n            node.startIndex = this.parser.startIndex;\r\n        }\r\n        if (this.options.withEndIndices) {\r\n            node.endIndex = this.parser.endIndex;\r\n        }\r\n        parent.children.push(node);\r\n        if (previousSibling) {\r\n            node.prev = previousSibling;\r\n            previousSibling.next = node;\r\n        }\r\n        node.parent = parent;\r\n        this.lastNode = null;\r\n    }\r\n}\r\nexport default DomHandler;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}