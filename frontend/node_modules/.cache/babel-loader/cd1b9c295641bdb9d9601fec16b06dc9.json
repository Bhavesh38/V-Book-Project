{"ast":null,"code":"//Const\nconst NOAH_ARK_CAPACITY = 3;\nexport var EntryType;\n(function (EntryType) {\n  EntryType[EntryType[\"Marker\"] = 0] = \"Marker\";\n  EntryType[EntryType[\"Element\"] = 1] = \"Element\";\n})(EntryType = EntryType || (EntryType = {}));\nconst MARKER = {\n  type: EntryType.Marker\n};\n//List of formatting elements\nexport class FormattingElementList {\n  constructor(treeAdapter) {\n    this.treeAdapter = treeAdapter;\n    this.entries = [];\n    this.bookmark = null;\n  }\n  //Noah Ark's condition\n  //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n  //lightweight heuristics without thorough attributes check.\n  _getNoahArkConditionCandidates(newElement, neAttrs) {\n    const candidates = [];\n    const neAttrsLength = neAttrs.length;\n    const neTagName = this.treeAdapter.getTagName(newElement);\n    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n    for (let i = 0; i < this.entries.length; i++) {\n      const entry = this.entries[i];\n      if (entry.type === EntryType.Marker) {\n        break;\n      }\n      const {\n        element\n      } = entry;\n      if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {\n        const elementAttrs = this.treeAdapter.getAttrList(element);\n        if (elementAttrs.length === neAttrsLength) {\n          candidates.push({\n            idx: i,\n            attrs: elementAttrs\n          });\n        }\n      }\n    }\n    return candidates;\n  }\n  _ensureNoahArkCondition(newElement) {\n    if (this.entries.length < NOAH_ARK_CAPACITY) return;\n    const neAttrs = this.treeAdapter.getAttrList(newElement);\n    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);\n    if (candidates.length < NOAH_ARK_CAPACITY) return;\n    //NOTE: build attrs map for the new element, so we can perform fast lookups\n    const neAttrsMap = new Map(neAttrs.map(neAttr => [neAttr.name, neAttr.value]));\n    let validCandidates = 0;\n    //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met\n    for (let i = 0; i < candidates.length; i++) {\n      const candidate = candidates[i];\n      // We know that `candidate.attrs.length === neAttrs.length`\n      if (candidate.attrs.every(cAttr => neAttrsMap.get(cAttr.name) === cAttr.value)) {\n        validCandidates += 1;\n        if (validCandidates >= NOAH_ARK_CAPACITY) {\n          this.entries.splice(candidate.idx, 1);\n        }\n      }\n    }\n  }\n  //Mutations\n  insertMarker() {\n    this.entries.unshift(MARKER);\n  }\n  pushElement(element, token) {\n    this._ensureNoahArkCondition(element);\n    this.entries.unshift({\n      type: EntryType.Element,\n      element,\n      token\n    });\n  }\n  insertElementAfterBookmark(element, token) {\n    const bookmarkIdx = this.entries.indexOf(this.bookmark);\n    this.entries.splice(bookmarkIdx, 0, {\n      type: EntryType.Element,\n      element,\n      token\n    });\n  }\n  removeEntry(entry) {\n    const entryIndex = this.entries.indexOf(entry);\n    if (entryIndex >= 0) {\n      this.entries.splice(entryIndex, 1);\n    }\n  }\n  /**\r\n   * Clears the list of formatting elements up to the last marker.\r\n   *\r\n   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker\r\n   */\n  clearToLastMarker() {\n    const markerIdx = this.entries.indexOf(MARKER);\n    if (markerIdx >= 0) {\n      this.entries.splice(0, markerIdx + 1);\n    } else {\n      this.entries.length = 0;\n    }\n  }\n  //Search\n  getElementEntryInScopeWithTagName(tagName) {\n    const entry = this.entries.find(entry => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);\n    return entry && entry.type === EntryType.Element ? entry : null;\n  }\n  getElementEntry(element) {\n    return this.entries.find(entry => entry.type === EntryType.Element && entry.element === element);\n  }\n}","map":{"version":3,"names":["NOAH_ARK_CAPACITY","EntryType","MARKER","type","Marker","FormattingElementList","constructor","treeAdapter","entries","bookmark","_getNoahArkConditionCandidates","newElement","neAttrs","candidates","neAttrsLength","length","neTagName","getTagName","neNamespaceURI","getNamespaceURI","i","entry","element","elementAttrs","getAttrList","push","idx","attrs","_ensureNoahArkCondition","neAttrsMap","Map","map","neAttr","name","value","validCandidates","candidate","every","cAttr","get","splice","insertMarker","unshift","pushElement","token","Element","insertElementAfterBookmark","bookmarkIdx","indexOf","removeEntry","entryIndex","clearToLastMarker","markerIdx","getElementEntryInScopeWithTagName","tagName","find","getElementEntry"],"sources":["D:/Work/V-Book/project/V-Book-Project/frontend/node_modules/parse5/dist/parser/formatting-element-list.js"],"sourcesContent":["//Const\r\nconst NOAH_ARK_CAPACITY = 3;\r\nexport var EntryType;\r\n(function (EntryType) {\r\n    EntryType[EntryType[\"Marker\"] = 0] = \"Marker\";\r\n    EntryType[EntryType[\"Element\"] = 1] = \"Element\";\r\n})(EntryType = EntryType || (EntryType = {}));\r\nconst MARKER = { type: EntryType.Marker };\r\n//List of formatting elements\r\nexport class FormattingElementList {\r\n    constructor(treeAdapter) {\r\n        this.treeAdapter = treeAdapter;\r\n        this.entries = [];\r\n        this.bookmark = null;\r\n    }\r\n    //Noah Ark's condition\r\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\r\n    //lightweight heuristics without thorough attributes check.\r\n    _getNoahArkConditionCandidates(newElement, neAttrs) {\r\n        const candidates = [];\r\n        const neAttrsLength = neAttrs.length;\r\n        const neTagName = this.treeAdapter.getTagName(newElement);\r\n        const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\r\n        for (let i = 0; i < this.entries.length; i++) {\r\n            const entry = this.entries[i];\r\n            if (entry.type === EntryType.Marker) {\r\n                break;\r\n            }\r\n            const { element } = entry;\r\n            if (this.treeAdapter.getTagName(element) === neTagName &&\r\n                this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {\r\n                const elementAttrs = this.treeAdapter.getAttrList(element);\r\n                if (elementAttrs.length === neAttrsLength) {\r\n                    candidates.push({ idx: i, attrs: elementAttrs });\r\n                }\r\n            }\r\n        }\r\n        return candidates;\r\n    }\r\n    _ensureNoahArkCondition(newElement) {\r\n        if (this.entries.length < NOAH_ARK_CAPACITY)\r\n            return;\r\n        const neAttrs = this.treeAdapter.getAttrList(newElement);\r\n        const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);\r\n        if (candidates.length < NOAH_ARK_CAPACITY)\r\n            return;\r\n        //NOTE: build attrs map for the new element, so we can perform fast lookups\r\n        const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));\r\n        let validCandidates = 0;\r\n        //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met\r\n        for (let i = 0; i < candidates.length; i++) {\r\n            const candidate = candidates[i];\r\n            // We know that `candidate.attrs.length === neAttrs.length`\r\n            if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {\r\n                validCandidates += 1;\r\n                if (validCandidates >= NOAH_ARK_CAPACITY) {\r\n                    this.entries.splice(candidate.idx, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    //Mutations\r\n    insertMarker() {\r\n        this.entries.unshift(MARKER);\r\n    }\r\n    pushElement(element, token) {\r\n        this._ensureNoahArkCondition(element);\r\n        this.entries.unshift({\r\n            type: EntryType.Element,\r\n            element,\r\n            token,\r\n        });\r\n    }\r\n    insertElementAfterBookmark(element, token) {\r\n        const bookmarkIdx = this.entries.indexOf(this.bookmark);\r\n        this.entries.splice(bookmarkIdx, 0, {\r\n            type: EntryType.Element,\r\n            element,\r\n            token,\r\n        });\r\n    }\r\n    removeEntry(entry) {\r\n        const entryIndex = this.entries.indexOf(entry);\r\n        if (entryIndex >= 0) {\r\n            this.entries.splice(entryIndex, 1);\r\n        }\r\n    }\r\n    /**\r\n     * Clears the list of formatting elements up to the last marker.\r\n     *\r\n     * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker\r\n     */\r\n    clearToLastMarker() {\r\n        const markerIdx = this.entries.indexOf(MARKER);\r\n        if (markerIdx >= 0) {\r\n            this.entries.splice(0, markerIdx + 1);\r\n        }\r\n        else {\r\n            this.entries.length = 0;\r\n        }\r\n    }\r\n    //Search\r\n    getElementEntryInScopeWithTagName(tagName) {\r\n        const entry = this.entries.find((entry) => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);\r\n        return entry && entry.type === EntryType.Element ? entry : null;\r\n    }\r\n    getElementEntry(element) {\r\n        return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);\r\n    }\r\n}\r\n//# sourceMappingURL=formatting-element-list.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}