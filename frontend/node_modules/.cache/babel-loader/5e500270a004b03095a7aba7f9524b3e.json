{"ast":null,"code":"import boolbase from \"boolbase\";\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n *\n * ```js\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n * ```\n */\nexport function compile(parsed) {\n  const a = parsed[0];\n  // Subtract 1 from `b`, to convert from one- to zero-indexed.\n  const b = parsed[1] - 1;\n  /*\n   * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n   * Besides, the specification states that no elements are\n   * matched when `a` and `b` are 0.\n   *\n   * `b < 0` here as we subtracted 1 from `b` above.\n   */\n  if (b < 0 && a <= 0) return boolbase.falseFunc;\n  // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n  if (a === -1) return index => index <= b;\n  if (a === 0) return index => index === b;\n  // When `b <= 0` and `a === 1`, they match any element.\n  if (a === 1) return b < 0 ? boolbase.trueFunc : index => index >= b;\n  /*\n   * Otherwise, modulo can be used to check if there is a match.\n   *\n   * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n   */\n  const absA = Math.abs(a);\n  // Get `b mod a`, + a if this is negative.\n  const bMod = (b % absA + absA) % absA;\n  return a > 1 ? index => index >= b && index % absA === bMod : index => index <= b && index % absA === bMod;\n}\n/**\n * Returns a function that produces a monotonously increasing sequence of indices.\n *\n * If the sequence has an end, the returned function will return `null` after\n * the last index in the sequence.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A function that produces a sequence of indices.\n * @example <caption>Always increasing (2n+3)</caption>\n *\n * ```js\n * const gen = nthCheck.generate([2, 3])\n *\n * gen() // `1`\n * gen() // `3`\n * gen() // `5`\n * gen() // `8`\n * gen() // `11`\n * ```\n *\n * @example <caption>With end value (-2n+10)</caption>\n *\n * ```js\n *\n * const gen = nthCheck.generate([-2, 5]);\n *\n * gen() // 0\n * gen() // 2\n * gen() // 4\n * gen() // null\n * ```\n */\nexport function generate(parsed) {\n  const a = parsed[0];\n  // Subtract 1 from `b`, to convert from one- to zero-indexed.\n  let b = parsed[1] - 1;\n  let n = 0;\n  // Make sure to always return an increasing sequence\n  if (a < 0) {\n    const aPos = -a;\n    // Get `b mod a`\n    const minValue = (b % aPos + aPos) % aPos;\n    return () => {\n      const val = minValue + aPos * n++;\n      return val > b ? null : val;\n    };\n  }\n  if (a === 0) return b < 0 ?\n  // There are no result â€” always return `null`\n  () => null :\n  // Return `b` exactly once\n  () => n++ === 0 ? b : null;\n  if (b < 0) {\n    b += a * Math.ceil(-b / a);\n  }\n  return () => a * n++ + b;\n}","map":{"version":3,"mappings":"AAAA,OAAOA,QAAQ,MAAM,UAAU;AAE/B;;;;;;;;;;;;;;;;;;;;AAoBA,OAAM,SAAUC,OAAO,CACnBC,MAA8B;EAE9B,MAAMC,CAAC,GAAGD,MAAM,CAAC,CAAC,CAAC;EACnB;EACA,MAAME,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC;EAEvB;;;;;;;EAOA,IAAIE,CAAC,GAAG,CAAC,IAAID,CAAC,IAAI,CAAC,EAAE,OAAOH,QAAQ,CAACK,SAAS;EAE9C;EACA,IAAIF,CAAC,KAAK,CAAC,CAAC,EAAE,OAAQG,KAAK,IAAKA,KAAK,IAAIF,CAAC;EAC1C,IAAID,CAAC,KAAK,CAAC,EAAE,OAAQG,KAAK,IAAKA,KAAK,KAAKF,CAAC;EAC1C;EACA,IAAID,CAAC,KAAK,CAAC,EAAE,OAAOC,CAAC,GAAG,CAAC,GAAGJ,QAAQ,CAACO,QAAQ,GAAID,KAAK,IAAKA,KAAK,IAAIF,CAAC;EAErE;;;;;EAKA,MAAMI,IAAI,GAAGC,IAAI,CAACC,GAAG,CAACP,CAAC,CAAC;EACxB;EACA,MAAMQ,IAAI,GAAG,CAAEP,CAAC,GAAGI,IAAI,GAAIA,IAAI,IAAIA,IAAI;EAEvC,OAAOL,CAAC,GAAG,CAAC,GACLG,KAAK,IAAKA,KAAK,IAAIF,CAAC,IAAIE,KAAK,GAAGE,IAAI,KAAKG,IAAI,GAC7CL,KAAK,IAAKA,KAAK,IAAIF,CAAC,IAAIE,KAAK,GAAGE,IAAI,KAAKG,IAAI;AACxD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,OAAM,SAAUC,QAAQ,CAACV,MAA8B;EACnD,MAAMC,CAAC,GAAGD,MAAM,CAAC,CAAC,CAAC;EACnB;EACA,IAAIE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC;EAErB,IAAIW,CAAC,GAAG,CAAC;EAET;EACA,IAAIV,CAAC,GAAG,CAAC,EAAE;IACP,MAAMW,IAAI,GAAG,CAACX,CAAC;IACf;IACA,MAAMY,QAAQ,GAAG,CAAEX,CAAC,GAAGU,IAAI,GAAIA,IAAI,IAAIA,IAAI;IAC3C,OAAO,MAAK;MACR,MAAME,GAAG,GAAGD,QAAQ,GAAGD,IAAI,GAAGD,CAAC,EAAE;MAEjC,OAAOG,GAAG,GAAGZ,CAAC,GAAG,IAAI,GAAGY,GAAG;IAC/B,CAAC;;EAGL,IAAIb,CAAC,KAAK,CAAC,EACP,OAAOC,CAAC,GAAG,CAAC;EACN;EACA,MAAM,IAAI;EACV;EACA,MAAOS,CAAC,EAAE,KAAK,CAAC,GAAGT,CAAC,GAAG,IAAK;EAEtC,IAAIA,CAAC,GAAG,CAAC,EAAE;IACPA,CAAC,IAAID,CAAC,GAAGM,IAAI,CAACQ,IAAI,CAAC,CAACb,CAAC,GAAGD,CAAC,CAAC;;EAG9B,OAAO,MAAMA,CAAC,GAAGU,CAAC,EAAE,GAAGT,CAAC;AAC5B","names":["boolbase","compile","parsed","a","b","falseFunc","index","trueFunc","absA","Math","abs","bMod","generate","n","aPos","minValue","val","ceil"],"sourceRoot":"https://raw.githubusercontent.com/fb55/nth-check/639fd2a4000b69f82350aad8c34cb43f77e483ba/src/","sources":["compile.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}