{"ast":null,"code":"import { CODE_POINTS as $, getSurrogatePairCodePoint, isControlCodePoint, isSurrogate, isSurrogatePair, isUndefinedCodePoint } from '../common/unicode.js';\nimport { ERR } from '../common/error-codes.js';\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nexport class Preprocessor {\n  constructor(handler) {\n    this.handler = handler;\n    this.html = '';\n    this.pos = -1;\n    // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n    this.lastGapPos = -2;\n    this.gapStack = [];\n    this.skipNextNewLine = false;\n    this.lastChunkWritten = false;\n    this.endOfChunkHit = false;\n    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n    this.isEol = false;\n    this.lineStartPos = 0;\n    this.droppedBufferSize = 0;\n    this.line = 1;\n    //NOTE: avoid reporting errors twice on advance/retreat\n    this.lastErrOffset = -1;\n  }\n  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n  get col() {\n    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n  }\n  get offset() {\n    return this.droppedBufferSize + this.pos;\n  }\n  getError(code) {\n    const {\n      line,\n      col,\n      offset\n    } = this;\n    return {\n      code,\n      startLine: line,\n      endLine: line,\n      startCol: col,\n      endCol: col,\n      startOffset: offset,\n      endOffset: offset\n    };\n  }\n  _err(code) {\n    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n      this.lastErrOffset = this.offset;\n      this.handler.onParseError(this.getError(code));\n    }\n  }\n  _addGap() {\n    this.gapStack.push(this.lastGapPos);\n    this.lastGapPos = this.pos;\n  }\n  _processSurrogate(cp) {\n    //NOTE: try to peek a surrogate pair\n    if (this.pos !== this.html.length - 1) {\n      const nextCp = this.html.charCodeAt(this.pos + 1);\n      if (isSurrogatePair(nextCp)) {\n        //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n        this.pos++;\n        //NOTE: add a gap that should be avoided during retreat\n        this._addGap();\n        return getSurrogatePairCodePoint(cp, nextCp);\n      }\n    }\n    //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n    else if (!this.lastChunkWritten) {\n      this.endOfChunkHit = true;\n      return $.EOF;\n    }\n    //NOTE: isolated surrogate\n    this._err(ERR.surrogateInInputStream);\n    return cp;\n  }\n  willDropParsedChunk() {\n    return this.pos > this.bufferWaterline;\n  }\n  dropParsedChunk() {\n    if (this.willDropParsedChunk()) {\n      this.html = this.html.substring(this.pos);\n      this.lineStartPos -= this.pos;\n      this.droppedBufferSize += this.pos;\n      this.pos = 0;\n      this.lastGapPos = -2;\n      this.gapStack.length = 0;\n    }\n  }\n  write(chunk, isLastChunk) {\n    if (this.html.length > 0) {\n      this.html += chunk;\n    } else {\n      this.html = chunk;\n    }\n    this.endOfChunkHit = false;\n    this.lastChunkWritten = isLastChunk;\n  }\n  insertHtmlAtCurrentPos(chunk) {\n    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n    this.endOfChunkHit = false;\n  }\n  startsWith(pattern, caseSensitive) {\n    // Check if our buffer has enough characters\n    if (this.pos + pattern.length > this.html.length) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return false;\n    }\n    if (caseSensitive) {\n      return this.html.startsWith(pattern, this.pos);\n    }\n    for (let i = 0; i < pattern.length; i++) {\n      const cp = this.html.charCodeAt(this.pos + i) | 0x20;\n      if (cp !== pattern.charCodeAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  peek(offset) {\n    const pos = this.pos + offset;\n    if (pos >= this.html.length) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return $.EOF;\n    }\n    const code = this.html.charCodeAt(pos);\n    return code === $.CARRIAGE_RETURN ? $.LINE_FEED : code;\n  }\n  advance() {\n    this.pos++;\n    //NOTE: LF should be in the last column of the line\n    if (this.isEol) {\n      this.isEol = false;\n      this.line++;\n      this.lineStartPos = this.pos;\n    }\n    if (this.pos >= this.html.length) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return $.EOF;\n    }\n    let cp = this.html.charCodeAt(this.pos);\n    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n    if (cp === $.CARRIAGE_RETURN) {\n      this.isEol = true;\n      this.skipNextNewLine = true;\n      return $.LINE_FEED;\n    }\n    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n    //must be ignored.\n    if (cp === $.LINE_FEED) {\n      this.isEol = true;\n      if (this.skipNextNewLine) {\n        // `line` will be bumped again in the recursive call.\n        this.line--;\n        this.skipNextNewLine = false;\n        this._addGap();\n        return this.advance();\n      }\n    }\n    this.skipNextNewLine = false;\n    if (isSurrogate(cp)) {\n      cp = this._processSurrogate(cp);\n    }\n    //OPTIMIZATION: first check if code point is in the common allowed\n    //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n    //before going into detailed performance cost validation.\n    const isCommonValidRange = this.handler.onParseError === null || cp > 0x1f && cp < 0x7f || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || cp > 0x9f && cp < 64976;\n    if (!isCommonValidRange) {\n      this._checkForProblematicCharacters(cp);\n    }\n    return cp;\n  }\n  _checkForProblematicCharacters(cp) {\n    if (isControlCodePoint(cp)) {\n      this._err(ERR.controlCharacterInInputStream);\n    } else if (isUndefinedCodePoint(cp)) {\n      this._err(ERR.noncharacterInInputStream);\n    }\n  }\n  retreat(count) {\n    this.pos -= count;\n    while (this.pos < this.lastGapPos) {\n      this.lastGapPos = this.gapStack.pop();\n      this.pos--;\n    }\n    this.isEol = false;\n  }\n}","map":{"version":3,"names":["CODE_POINTS","$","getSurrogatePairCodePoint","isControlCodePoint","isSurrogate","isSurrogatePair","isUndefinedCodePoint","ERR","DEFAULT_BUFFER_WATERLINE","Preprocessor","constructor","handler","html","pos","lastGapPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","bufferWaterline","isEol","lineStartPos","droppedBufferSize","line","lastErrOffset","col","Number","offset","getError","code","startLine","endLine","startCol","endCol","startOffset","endOffset","_err","onParseError","_addGap","push","_processSurrogate","cp","length","nextCp","charCodeAt","EOF","surrogateInInputStream","willDropParsedChunk","dropParsedChunk","substring","write","chunk","isLastChunk","insertHtmlAtCurrentPos","startsWith","pattern","caseSensitive","i","peek","CARRIAGE_RETURN","LINE_FEED","advance","isCommonValidRange","_checkForProblematicCharacters","controlCharacterInInputStream","noncharacterInInputStream","retreat","count","pop"],"sources":["D:/Work/V-Book/project/V-Book-Project/frontend/node_modules/parse5/dist/tokenizer/preprocessor.js"],"sourcesContent":["import { CODE_POINTS as $, getSurrogatePairCodePoint, isControlCodePoint, isSurrogate, isSurrogatePair, isUndefinedCodePoint, } from '../common/unicode.js';\r\nimport { ERR } from '../common/error-codes.js';\r\n//Const\r\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\r\n//Preprocessor\r\n//NOTE: HTML input preprocessing\r\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\r\nexport class Preprocessor {\r\n    constructor(handler) {\r\n        this.handler = handler;\r\n        this.html = '';\r\n        this.pos = -1;\r\n        // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\r\n        this.lastGapPos = -2;\r\n        this.gapStack = [];\r\n        this.skipNextNewLine = false;\r\n        this.lastChunkWritten = false;\r\n        this.endOfChunkHit = false;\r\n        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\r\n        this.isEol = false;\r\n        this.lineStartPos = 0;\r\n        this.droppedBufferSize = 0;\r\n        this.line = 1;\r\n        //NOTE: avoid reporting errors twice on advance/retreat\r\n        this.lastErrOffset = -1;\r\n    }\r\n    /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\r\n    get col() {\r\n        return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\r\n    }\r\n    get offset() {\r\n        return this.droppedBufferSize + this.pos;\r\n    }\r\n    getError(code) {\r\n        const { line, col, offset } = this;\r\n        return {\r\n            code,\r\n            startLine: line,\r\n            endLine: line,\r\n            startCol: col,\r\n            endCol: col,\r\n            startOffset: offset,\r\n            endOffset: offset,\r\n        };\r\n    }\r\n    _err(code) {\r\n        if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\r\n            this.lastErrOffset = this.offset;\r\n            this.handler.onParseError(this.getError(code));\r\n        }\r\n    }\r\n    _addGap() {\r\n        this.gapStack.push(this.lastGapPos);\r\n        this.lastGapPos = this.pos;\r\n    }\r\n    _processSurrogate(cp) {\r\n        //NOTE: try to peek a surrogate pair\r\n        if (this.pos !== this.html.length - 1) {\r\n            const nextCp = this.html.charCodeAt(this.pos + 1);\r\n            if (isSurrogatePair(nextCp)) {\r\n                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\r\n                this.pos++;\r\n                //NOTE: add a gap that should be avoided during retreat\r\n                this._addGap();\r\n                return getSurrogatePairCodePoint(cp, nextCp);\r\n            }\r\n        }\r\n        //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\r\n        else if (!this.lastChunkWritten) {\r\n            this.endOfChunkHit = true;\r\n            return $.EOF;\r\n        }\r\n        //NOTE: isolated surrogate\r\n        this._err(ERR.surrogateInInputStream);\r\n        return cp;\r\n    }\r\n    willDropParsedChunk() {\r\n        return this.pos > this.bufferWaterline;\r\n    }\r\n    dropParsedChunk() {\r\n        if (this.willDropParsedChunk()) {\r\n            this.html = this.html.substring(this.pos);\r\n            this.lineStartPos -= this.pos;\r\n            this.droppedBufferSize += this.pos;\r\n            this.pos = 0;\r\n            this.lastGapPos = -2;\r\n            this.gapStack.length = 0;\r\n        }\r\n    }\r\n    write(chunk, isLastChunk) {\r\n        if (this.html.length > 0) {\r\n            this.html += chunk;\r\n        }\r\n        else {\r\n            this.html = chunk;\r\n        }\r\n        this.endOfChunkHit = false;\r\n        this.lastChunkWritten = isLastChunk;\r\n    }\r\n    insertHtmlAtCurrentPos(chunk) {\r\n        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\r\n        this.endOfChunkHit = false;\r\n    }\r\n    startsWith(pattern, caseSensitive) {\r\n        // Check if our buffer has enough characters\r\n        if (this.pos + pattern.length > this.html.length) {\r\n            this.endOfChunkHit = !this.lastChunkWritten;\r\n            return false;\r\n        }\r\n        if (caseSensitive) {\r\n            return this.html.startsWith(pattern, this.pos);\r\n        }\r\n        for (let i = 0; i < pattern.length; i++) {\r\n            const cp = this.html.charCodeAt(this.pos + i) | 0x20;\r\n            if (cp !== pattern.charCodeAt(i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    peek(offset) {\r\n        const pos = this.pos + offset;\r\n        if (pos >= this.html.length) {\r\n            this.endOfChunkHit = !this.lastChunkWritten;\r\n            return $.EOF;\r\n        }\r\n        const code = this.html.charCodeAt(pos);\r\n        return code === $.CARRIAGE_RETURN ? $.LINE_FEED : code;\r\n    }\r\n    advance() {\r\n        this.pos++;\r\n        //NOTE: LF should be in the last column of the line\r\n        if (this.isEol) {\r\n            this.isEol = false;\r\n            this.line++;\r\n            this.lineStartPos = this.pos;\r\n        }\r\n        if (this.pos >= this.html.length) {\r\n            this.endOfChunkHit = !this.lastChunkWritten;\r\n            return $.EOF;\r\n        }\r\n        let cp = this.html.charCodeAt(this.pos);\r\n        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\r\n        if (cp === $.CARRIAGE_RETURN) {\r\n            this.isEol = true;\r\n            this.skipNextNewLine = true;\r\n            return $.LINE_FEED;\r\n        }\r\n        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\r\n        //must be ignored.\r\n        if (cp === $.LINE_FEED) {\r\n            this.isEol = true;\r\n            if (this.skipNextNewLine) {\r\n                // `line` will be bumped again in the recursive call.\r\n                this.line--;\r\n                this.skipNextNewLine = false;\r\n                this._addGap();\r\n                return this.advance();\r\n            }\r\n        }\r\n        this.skipNextNewLine = false;\r\n        if (isSurrogate(cp)) {\r\n            cp = this._processSurrogate(cp);\r\n        }\r\n        //OPTIMIZATION: first check if code point is in the common allowed\r\n        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\r\n        //before going into detailed performance cost validation.\r\n        const isCommonValidRange = this.handler.onParseError === null ||\r\n            (cp > 0x1f && cp < 0x7f) ||\r\n            cp === $.LINE_FEED ||\r\n            cp === $.CARRIAGE_RETURN ||\r\n            (cp > 0x9f && cp < 64976);\r\n        if (!isCommonValidRange) {\r\n            this._checkForProblematicCharacters(cp);\r\n        }\r\n        return cp;\r\n    }\r\n    _checkForProblematicCharacters(cp) {\r\n        if (isControlCodePoint(cp)) {\r\n            this._err(ERR.controlCharacterInInputStream);\r\n        }\r\n        else if (isUndefinedCodePoint(cp)) {\r\n            this._err(ERR.noncharacterInInputStream);\r\n        }\r\n    }\r\n    retreat(count) {\r\n        this.pos -= count;\r\n        while (this.pos < this.lastGapPos) {\r\n            this.lastGapPos = this.gapStack.pop();\r\n            this.pos--;\r\n        }\r\n        this.isEol = false;\r\n    }\r\n}\r\n//# sourceMappingURL=preprocessor.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}