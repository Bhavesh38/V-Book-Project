{"ast":null,"code":"import { ElementType, isTag as isTagRaw } from \"domelementtype\";\n/**\r\n * This object will be used as the prototype for Nodes when creating a\r\n * DOM-Level-1-compliant structure.\r\n */\nexport class Node {\n  constructor() {\n    /** Parent of the node */\n    this.parent = null;\n    /** Previous sibling */\n    this.prev = null;\n    /** Next sibling */\n    this.next = null;\n    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n    this.startIndex = null;\n    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n    this.endIndex = null;\n  }\n  // Read-write aliases for properties\n  /**\r\n   * Same as {@link parent}.\r\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n   */\n  get parentNode() {\n    return this.parent;\n  }\n  set parentNode(parent) {\n    this.parent = parent;\n  }\n  /**\r\n   * Same as {@link prev}.\r\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n   */\n  get previousSibling() {\n    return this.prev;\n  }\n  set previousSibling(prev) {\n    this.prev = prev;\n  }\n  /**\r\n   * Same as {@link next}.\r\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n   */\n  get nextSibling() {\n    return this.next;\n  }\n  set nextSibling(next) {\n    this.next = next;\n  }\n  /**\r\n   * Clone this node, and optionally its children.\r\n   *\r\n   * @param recursive Clone child nodes as well.\r\n   * @returns A clone of the node.\r\n   */\n  cloneNode() {\n    let recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return cloneNode(this, recursive);\n  }\n}\n/**\r\n * A node that contains some data.\r\n */\nexport class DataNode extends Node {\n  /**\r\n   * @param data The content of the data node\r\n   */\n  constructor(data) {\n    super();\n    this.data = data;\n  }\n  /**\r\n   * Same as {@link data}.\r\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n   */\n  get nodeValue() {\n    return this.data;\n  }\n  set nodeValue(data) {\n    this.data = data;\n  }\n}\n/**\r\n * Text within the document.\r\n */\nexport class Text extends DataNode {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Text;\n  }\n  get nodeType() {\n    return 3;\n  }\n}\n/**\r\n * Comments within the document.\r\n */\nexport class Comment extends DataNode {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Comment;\n  }\n  get nodeType() {\n    return 8;\n  }\n}\n/**\r\n * Processing instructions, including doc types.\r\n */\nexport class ProcessingInstruction extends DataNode {\n  constructor(name, data) {\n    super(data);\n    this.name = name;\n    this.type = ElementType.Directive;\n  }\n  get nodeType() {\n    return 1;\n  }\n}\n/**\r\n * A `Node` that can have children.\r\n */\nexport class NodeWithChildren extends Node {\n  /**\r\n   * @param children Children of the node. Only certain node types can have children.\r\n   */\n  constructor(children) {\n    super();\n    this.children = children;\n  }\n  // Aliases\n  /** First child of the node. */\n  get firstChild() {\n    var _a;\n    return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n  }\n  /** Last child of the node. */\n  get lastChild() {\n    return this.children.length > 0 ? this.children[this.children.length - 1] : null;\n  }\n  /**\r\n   * Same as {@link children}.\r\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n   */\n  get childNodes() {\n    return this.children;\n  }\n  set childNodes(children) {\n    this.children = children;\n  }\n}\nexport class CDATA extends NodeWithChildren {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.CDATA;\n  }\n  get nodeType() {\n    return 4;\n  }\n}\n/**\r\n * The root node of the document.\r\n */\nexport class Document extends NodeWithChildren {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Root;\n  }\n  get nodeType() {\n    return 9;\n  }\n}\n/**\r\n * An element within the DOM.\r\n */\nexport class Element extends NodeWithChildren {\n  /**\r\n   * @param name Name of the tag, eg. `div`, `span`.\r\n   * @param attribs Object mapping attribute names to attribute values.\r\n   * @param children Children of the node.\r\n   */\n  constructor(name, attribs) {\n    let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : name === \"script\" ? ElementType.Script : name === \"style\" ? ElementType.Style : ElementType.Tag;\n    super(children);\n    this.name = name;\n    this.attribs = attribs;\n    this.type = type;\n  }\n  get nodeType() {\n    return 1;\n  }\n  // DOM Level 1 aliases\n  /**\r\n   * Same as {@link name}.\r\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n   */\n  get tagName() {\n    return this.name;\n  }\n  set tagName(name) {\n    this.name = name;\n  }\n  get attributes() {\n    return Object.keys(this.attribs).map(name => {\n      var _a, _b;\n      return {\n        name,\n        value: this.attribs[name],\n        namespace: (_a = this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n        prefix: (_b = this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name]\n      };\n    });\n  }\n}\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node is a `Element`, `false` otherwise.\r\n */\nexport function isTag(node) {\n  return isTagRaw(node);\n}\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\r\n */\nexport function isCDATA(node) {\n  return node.type === ElementType.CDATA;\n}\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has the type `Text`, `false` otherwise.\r\n */\nexport function isText(node) {\n  return node.type === ElementType.Text;\n}\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\r\n */\nexport function isComment(node) {\n  return node.type === ElementType.Comment;\n}\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\r\n */\nexport function isDirective(node) {\n  return node.type === ElementType.Directive;\n}\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\r\n */\nexport function isDocument(node) {\n  return node.type === ElementType.Root;\n}\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has children, `false` otherwise.\r\n */\nexport function hasChildren(node) {\n  return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\n/**\r\n * Clone a node, and optionally its children.\r\n *\r\n * @param recursive Clone child nodes as well.\r\n * @returns A clone of the node.\r\n */\nexport function cloneNode(node) {\n  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let result;\n  if (isText(node)) {\n    result = new Text(node.data);\n  } else if (isComment(node)) {\n    result = new Comment(node.data);\n  } else if (isTag(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new Element(node.name, {\n      ...node.attribs\n    }, children);\n    children.forEach(child => child.parent = clone);\n    if (node.namespace != null) {\n      clone.namespace = node.namespace;\n    }\n    if (node[\"x-attribsNamespace\"]) {\n      clone[\"x-attribsNamespace\"] = {\n        ...node[\"x-attribsNamespace\"]\n      };\n    }\n    if (node[\"x-attribsPrefix\"]) {\n      clone[\"x-attribsPrefix\"] = {\n        ...node[\"x-attribsPrefix\"]\n      };\n    }\n    result = clone;\n  } else if (isCDATA(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new CDATA(children);\n    children.forEach(child => child.parent = clone);\n    result = clone;\n  } else if (isDocument(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new Document(children);\n    children.forEach(child => child.parent = clone);\n    if (node[\"x-mode\"]) {\n      clone[\"x-mode\"] = node[\"x-mode\"];\n    }\n    result = clone;\n  } else if (isDirective(node)) {\n    const instruction = new ProcessingInstruction(node.name, node.data);\n    if (node[\"x-name\"] != null) {\n      instruction[\"x-name\"] = node[\"x-name\"];\n      instruction[\"x-publicId\"] = node[\"x-publicId\"];\n      instruction[\"x-systemId\"] = node[\"x-systemId\"];\n    }\n    result = instruction;\n  } else {\n    throw new Error(`Not implemented yet: ${node.type}`);\n  }\n  result.startIndex = node.startIndex;\n  result.endIndex = node.endIndex;\n  if (node.sourceCodeLocation != null) {\n    result.sourceCodeLocation = node.sourceCodeLocation;\n  }\n  return result;\n}\nfunction cloneChildren(childs) {\n  const children = childs.map(child => cloneNode(child, true));\n  for (let i = 1; i < children.length; i++) {\n    children[i].prev = children[i - 1];\n    children[i - 1].next = children[i];\n  }\n  return children;\n}","map":{"version":3,"names":["ElementType","isTag","isTagRaw","Node","constructor","parent","prev","next","startIndex","endIndex","parentNode","previousSibling","nextSibling","cloneNode","recursive","DataNode","data","nodeValue","Text","arguments","type","nodeType","Comment","ProcessingInstruction","name","Directive","NodeWithChildren","children","firstChild","_a","lastChild","length","childNodes","CDATA","Document","Root","Element","attribs","Script","Style","Tag","tagName","attributes","Object","keys","map","_b","value","namespace","prefix","node","isCDATA","isText","isComment","isDirective","isDocument","hasChildren","prototype","hasOwnProperty","call","result","cloneChildren","clone","forEach","child","instruction","Error","sourceCodeLocation","childs","i"],"sources":["D:/Work/V-Book/project/V-Book-Project/frontend/node_modules/domhandler/lib/esm/node.js"],"sourcesContent":["import { ElementType, isTag as isTagRaw } from \"domelementtype\";\r\n/**\r\n * This object will be used as the prototype for Nodes when creating a\r\n * DOM-Level-1-compliant structure.\r\n */\r\nexport class Node {\r\n    constructor() {\r\n        /** Parent of the node */\r\n        this.parent = null;\r\n        /** Previous sibling */\r\n        this.prev = null;\r\n        /** Next sibling */\r\n        this.next = null;\r\n        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\r\n        this.startIndex = null;\r\n        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\r\n        this.endIndex = null;\r\n    }\r\n    // Read-write aliases for properties\r\n    /**\r\n     * Same as {@link parent}.\r\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n     */\r\n    get parentNode() {\r\n        return this.parent;\r\n    }\r\n    set parentNode(parent) {\r\n        this.parent = parent;\r\n    }\r\n    /**\r\n     * Same as {@link prev}.\r\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n     */\r\n    get previousSibling() {\r\n        return this.prev;\r\n    }\r\n    set previousSibling(prev) {\r\n        this.prev = prev;\r\n    }\r\n    /**\r\n     * Same as {@link next}.\r\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n     */\r\n    get nextSibling() {\r\n        return this.next;\r\n    }\r\n    set nextSibling(next) {\r\n        this.next = next;\r\n    }\r\n    /**\r\n     * Clone this node, and optionally its children.\r\n     *\r\n     * @param recursive Clone child nodes as well.\r\n     * @returns A clone of the node.\r\n     */\r\n    cloneNode(recursive = false) {\r\n        return cloneNode(this, recursive);\r\n    }\r\n}\r\n/**\r\n * A node that contains some data.\r\n */\r\nexport class DataNode extends Node {\r\n    /**\r\n     * @param data The content of the data node\r\n     */\r\n    constructor(data) {\r\n        super();\r\n        this.data = data;\r\n    }\r\n    /**\r\n     * Same as {@link data}.\r\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n     */\r\n    get nodeValue() {\r\n        return this.data;\r\n    }\r\n    set nodeValue(data) {\r\n        this.data = data;\r\n    }\r\n}\r\n/**\r\n * Text within the document.\r\n */\r\nexport class Text extends DataNode {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = ElementType.Text;\r\n    }\r\n    get nodeType() {\r\n        return 3;\r\n    }\r\n}\r\n/**\r\n * Comments within the document.\r\n */\r\nexport class Comment extends DataNode {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = ElementType.Comment;\r\n    }\r\n    get nodeType() {\r\n        return 8;\r\n    }\r\n}\r\n/**\r\n * Processing instructions, including doc types.\r\n */\r\nexport class ProcessingInstruction extends DataNode {\r\n    constructor(name, data) {\r\n        super(data);\r\n        this.name = name;\r\n        this.type = ElementType.Directive;\r\n    }\r\n    get nodeType() {\r\n        return 1;\r\n    }\r\n}\r\n/**\r\n * A `Node` that can have children.\r\n */\r\nexport class NodeWithChildren extends Node {\r\n    /**\r\n     * @param children Children of the node. Only certain node types can have children.\r\n     */\r\n    constructor(children) {\r\n        super();\r\n        this.children = children;\r\n    }\r\n    // Aliases\r\n    /** First child of the node. */\r\n    get firstChild() {\r\n        var _a;\r\n        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\r\n    }\r\n    /** Last child of the node. */\r\n    get lastChild() {\r\n        return this.children.length > 0\r\n            ? this.children[this.children.length - 1]\r\n            : null;\r\n    }\r\n    /**\r\n     * Same as {@link children}.\r\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n     */\r\n    get childNodes() {\r\n        return this.children;\r\n    }\r\n    set childNodes(children) {\r\n        this.children = children;\r\n    }\r\n}\r\nexport class CDATA extends NodeWithChildren {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = ElementType.CDATA;\r\n    }\r\n    get nodeType() {\r\n        return 4;\r\n    }\r\n}\r\n/**\r\n * The root node of the document.\r\n */\r\nexport class Document extends NodeWithChildren {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = ElementType.Root;\r\n    }\r\n    get nodeType() {\r\n        return 9;\r\n    }\r\n}\r\n/**\r\n * An element within the DOM.\r\n */\r\nexport class Element extends NodeWithChildren {\r\n    /**\r\n     * @param name Name of the tag, eg. `div`, `span`.\r\n     * @param attribs Object mapping attribute names to attribute values.\r\n     * @param children Children of the node.\r\n     */\r\n    constructor(name, attribs, children = [], type = name === \"script\"\r\n        ? ElementType.Script\r\n        : name === \"style\"\r\n            ? ElementType.Style\r\n            : ElementType.Tag) {\r\n        super(children);\r\n        this.name = name;\r\n        this.attribs = attribs;\r\n        this.type = type;\r\n    }\r\n    get nodeType() {\r\n        return 1;\r\n    }\r\n    // DOM Level 1 aliases\r\n    /**\r\n     * Same as {@link name}.\r\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\r\n     */\r\n    get tagName() {\r\n        return this.name;\r\n    }\r\n    set tagName(name) {\r\n        this.name = name;\r\n    }\r\n    get attributes() {\r\n        return Object.keys(this.attribs).map((name) => {\r\n            var _a, _b;\r\n            return ({\r\n                name,\r\n                value: this.attribs[name],\r\n                namespace: (_a = this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\r\n                prefix: (_b = this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name],\r\n            });\r\n        });\r\n    }\r\n}\r\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node is a `Element`, `false` otherwise.\r\n */\r\nexport function isTag(node) {\r\n    return isTagRaw(node);\r\n}\r\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\r\n */\r\nexport function isCDATA(node) {\r\n    return node.type === ElementType.CDATA;\r\n}\r\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has the type `Text`, `false` otherwise.\r\n */\r\nexport function isText(node) {\r\n    return node.type === ElementType.Text;\r\n}\r\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\r\n */\r\nexport function isComment(node) {\r\n    return node.type === ElementType.Comment;\r\n}\r\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\r\n */\r\nexport function isDirective(node) {\r\n    return node.type === ElementType.Directive;\r\n}\r\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\r\n */\r\nexport function isDocument(node) {\r\n    return node.type === ElementType.Root;\r\n}\r\n/**\r\n * @param node Node to check.\r\n * @returns `true` if the node has children, `false` otherwise.\r\n */\r\nexport function hasChildren(node) {\r\n    return Object.prototype.hasOwnProperty.call(node, \"children\");\r\n}\r\n/**\r\n * Clone a node, and optionally its children.\r\n *\r\n * @param recursive Clone child nodes as well.\r\n * @returns A clone of the node.\r\n */\r\nexport function cloneNode(node, recursive = false) {\r\n    let result;\r\n    if (isText(node)) {\r\n        result = new Text(node.data);\r\n    }\r\n    else if (isComment(node)) {\r\n        result = new Comment(node.data);\r\n    }\r\n    else if (isTag(node)) {\r\n        const children = recursive ? cloneChildren(node.children) : [];\r\n        const clone = new Element(node.name, { ...node.attribs }, children);\r\n        children.forEach((child) => (child.parent = clone));\r\n        if (node.namespace != null) {\r\n            clone.namespace = node.namespace;\r\n        }\r\n        if (node[\"x-attribsNamespace\"]) {\r\n            clone[\"x-attribsNamespace\"] = { ...node[\"x-attribsNamespace\"] };\r\n        }\r\n        if (node[\"x-attribsPrefix\"]) {\r\n            clone[\"x-attribsPrefix\"] = { ...node[\"x-attribsPrefix\"] };\r\n        }\r\n        result = clone;\r\n    }\r\n    else if (isCDATA(node)) {\r\n        const children = recursive ? cloneChildren(node.children) : [];\r\n        const clone = new CDATA(children);\r\n        children.forEach((child) => (child.parent = clone));\r\n        result = clone;\r\n    }\r\n    else if (isDocument(node)) {\r\n        const children = recursive ? cloneChildren(node.children) : [];\r\n        const clone = new Document(children);\r\n        children.forEach((child) => (child.parent = clone));\r\n        if (node[\"x-mode\"]) {\r\n            clone[\"x-mode\"] = node[\"x-mode\"];\r\n        }\r\n        result = clone;\r\n    }\r\n    else if (isDirective(node)) {\r\n        const instruction = new ProcessingInstruction(node.name, node.data);\r\n        if (node[\"x-name\"] != null) {\r\n            instruction[\"x-name\"] = node[\"x-name\"];\r\n            instruction[\"x-publicId\"] = node[\"x-publicId\"];\r\n            instruction[\"x-systemId\"] = node[\"x-systemId\"];\r\n        }\r\n        result = instruction;\r\n    }\r\n    else {\r\n        throw new Error(`Not implemented yet: ${node.type}`);\r\n    }\r\n    result.startIndex = node.startIndex;\r\n    result.endIndex = node.endIndex;\r\n    if (node.sourceCodeLocation != null) {\r\n        result.sourceCodeLocation = node.sourceCodeLocation;\r\n    }\r\n    return result;\r\n}\r\nfunction cloneChildren(childs) {\r\n    const children = childs.map((child) => cloneNode(child, true));\r\n    for (let i = 1; i < children.length; i++) {\r\n        children[i].prev = children[i - 1];\r\n        children[i - 1].next = children[i];\r\n    }\r\n    return children;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}