{"ast":null,"code":"import { SelectorType, AttributeAction } from \"./types\";\nconst reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\nconst reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\nconst actionTypes = new Map([[126 /* Tilde */, AttributeAction.Element], [94 /* Circumflex */, AttributeAction.Start], [36 /* Dollar */, AttributeAction.End], [42 /* Asterisk */, AttributeAction.Any], [33 /* ExclamationMark */, AttributeAction.Not], [124 /* Pipe */, AttributeAction.Hyphen]]);\n// Pseudos, whose data property is parsed as well.\nconst unpackPseudos = new Set([\"has\", \"not\", \"matches\", \"is\", \"where\", \"host\", \"host-context\"]);\n/**\r\n * Checks whether a specific selector is a traversal.\r\n * This is useful eg. in swapping the order of elements that\r\n * are not traversals.\r\n *\r\n * @param selector Selector to check.\r\n */\nexport function isTraversal(selector) {\n  switch (selector.type) {\n    case SelectorType.Adjacent:\n    case SelectorType.Child:\n    case SelectorType.Descendant:\n    case SelectorType.Parent:\n    case SelectorType.Sibling:\n    case SelectorType.ColumnCombinator:\n      return true;\n    default:\n      return false;\n  }\n}\nconst stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]);\n// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\nfunction funescape(_, escaped, escapedWhitespace) {\n  const high = parseInt(escaped, 16) - 0x10000;\n  // NaN means non-codepoint\n  return high !== high || escapedWhitespace ? escaped : high < 0 ?\n  // BMP codepoint\n  String.fromCharCode(high + 0x10000) :\n  // Supplemental Plane codepoint (surrogate pair)\n  String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);\n}\nfunction unescapeCSS(str) {\n  return str.replace(reEscape, funescape);\n}\nfunction isQuote(c) {\n  return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n\nfunction isWhitespace(c) {\n  return c === 32 /* Space */ || c === 9 /* Tab */ || c === 10 /* NewLine */ || c === 12 /* FormFeed */ || c === 13 /* CarriageReturn */;\n}\n/**\r\n * Parses `selector`, optionally with the passed `options`.\r\n *\r\n * @param selector Selector to parse.\r\n * @param options Options for parsing.\r\n * @returns Returns a two-dimensional array.\r\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\r\n * the second contains the relevant tokens for that selector.\r\n */\nexport function parse(selector) {\n  const subselects = [];\n  const endIndex = parseSelector(subselects, `${selector}`, 0);\n  if (endIndex < selector.length) {\n    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);\n  }\n  return subselects;\n}\nfunction parseSelector(subselects, selector, selectorIndex) {\n  let tokens = [];\n  function getName(offset) {\n    const match = selector.slice(selectorIndex + offset).match(reName);\n    if (!match) {\n      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);\n    }\n    const [name] = match;\n    selectorIndex += offset + name.length;\n    return unescapeCSS(name);\n  }\n  function stripWhitespace(offset) {\n    selectorIndex += offset;\n    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {\n      selectorIndex++;\n    }\n  }\n  function readValueWithParenthesis() {\n    selectorIndex += 1;\n    const start = selectorIndex;\n    let counter = 1;\n    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\n      if (selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */ && !isEscaped(selectorIndex)) {\n        counter++;\n      } else if (selector.charCodeAt(selectorIndex) === 41 /* RightParenthesis */ && !isEscaped(selectorIndex)) {\n        counter--;\n      }\n    }\n    if (counter) {\n      throw new Error(\"Parenthesis not matched\");\n    }\n    return unescapeCSS(selector.slice(start, selectorIndex - 1));\n  }\n  function isEscaped(pos) {\n    let slashCount = 0;\n    while (selector.charCodeAt(--pos) === 92 /* BackSlash */) slashCount++;\n    return (slashCount & 1) === 1;\n  }\n  function ensureNotTraversal() {\n    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\n      throw new Error(\"Did not expect successive traversals.\");\n    }\n  }\n  function addTraversal(type) {\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {\n      tokens[tokens.length - 1].type = type;\n      return;\n    }\n    ensureNotTraversal();\n    tokens.push({\n      type\n    });\n  }\n  function addSpecialAttribute(name, action) {\n    tokens.push({\n      type: SelectorType.Attribute,\n      name,\n      action,\n      value: getName(1),\n      namespace: null,\n      ignoreCase: \"quirks\"\n    });\n  }\n  /**\r\n   * We have finished parsing the current part of the selector.\r\n   *\r\n   * Remove descendant tokens at the end if they exist,\r\n   * and return the last index, so that parsing can be\r\n   * picked up from here.\r\n   */\n  function finalizeSubselector() {\n    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {\n      tokens.pop();\n    }\n    if (tokens.length === 0) {\n      throw new Error(\"Empty sub-selector\");\n    }\n    subselects.push(tokens);\n  }\n  stripWhitespace(0);\n  if (selector.length === selectorIndex) {\n    return selectorIndex;\n  }\n  loop: while (selectorIndex < selector.length) {\n    const firstChar = selector.charCodeAt(selectorIndex);\n    switch (firstChar) {\n      // Whitespace\n      case 32 /* Space */:\n      case 9 /* Tab */:\n      case 10 /* NewLine */:\n      case 12 /* FormFeed */:\n      case 13 /* CarriageReturn */:\n        {\n          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {\n            ensureNotTraversal();\n            tokens.push({\n              type: SelectorType.Descendant\n            });\n          }\n          stripWhitespace(1);\n          break;\n        }\n      // Traversals\n      case 62 /* GreaterThan */:\n        {\n          addTraversal(SelectorType.Child);\n          stripWhitespace(1);\n          break;\n        }\n      case 60 /* LessThan */:\n        {\n          addTraversal(SelectorType.Parent);\n          stripWhitespace(1);\n          break;\n        }\n      case 126 /* Tilde */:\n        {\n          addTraversal(SelectorType.Sibling);\n          stripWhitespace(1);\n          break;\n        }\n      case 43 /* Plus */:\n        {\n          addTraversal(SelectorType.Adjacent);\n          stripWhitespace(1);\n          break;\n        }\n      // Special attribute selectors: .class, #id\n      case 46 /* Period */:\n        {\n          addSpecialAttribute(\"class\", AttributeAction.Element);\n          break;\n        }\n      case 35 /* Hash */:\n        {\n          addSpecialAttribute(\"id\", AttributeAction.Equals);\n          break;\n        }\n      case 91 /* LeftSquareBracket */:\n        {\n          stripWhitespace(1);\n          // Determine attribute name and namespace\n          let name;\n          let namespace = null;\n          if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {\n            // Equivalent to no namespace\n            name = getName(1);\n          } else if (selector.startsWith(\"*|\", selectorIndex)) {\n            namespace = \"*\";\n            name = getName(2);\n          } else {\n            name = getName(0);\n            if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ && selector.charCodeAt(selectorIndex + 1) !== 61 /* Equal */) {\n              namespace = name;\n              name = getName(1);\n            }\n          }\n          stripWhitespace(0);\n          // Determine comparison operation\n          let action = AttributeAction.Exists;\n          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\n          if (possibleAction) {\n            action = possibleAction;\n            if (selector.charCodeAt(selectorIndex + 1) !== 61 /* Equal */) {\n              throw new Error(\"Expected `=`\");\n            }\n            stripWhitespace(2);\n          } else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {\n            action = AttributeAction.Equals;\n            stripWhitespace(1);\n          }\n          // Determine value\n          let value = \"\";\n          let ignoreCase = null;\n          if (action !== \"exists\") {\n            if (isQuote(selector.charCodeAt(selectorIndex))) {\n              const quote = selector.charCodeAt(selectorIndex);\n              let sectionEnd = selectorIndex + 1;\n              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {\n                sectionEnd += 1;\n              }\n              if (selector.charCodeAt(sectionEnd) !== quote) {\n                throw new Error(\"Attribute value didn't end\");\n              }\n              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\n              selectorIndex = sectionEnd + 1;\n            } else {\n              const valueStart = selectorIndex;\n              while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 /* RightSquareBracket */ || isEscaped(selectorIndex))) {\n                selectorIndex += 1;\n              }\n              value = unescapeCSS(selector.slice(valueStart, selectorIndex));\n            }\n            stripWhitespace(0);\n            // See if we have a force ignore flag\n            const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;\n            // If the forceIgnore flag is set (either `i` or `s`), use that value\n            if (forceIgnore === 115 /* LowerS */) {\n              ignoreCase = false;\n              stripWhitespace(1);\n            } else if (forceIgnore === 105 /* LowerI */) {\n              ignoreCase = true;\n              stripWhitespace(1);\n            }\n          }\n          if (selector.charCodeAt(selectorIndex) !== 93 /* RightSquareBracket */) {\n            throw new Error(\"Attribute selector didn't terminate\");\n          }\n          selectorIndex += 1;\n          const attributeSelector = {\n            type: SelectorType.Attribute,\n            name,\n            action,\n            value,\n            namespace,\n            ignoreCase\n          };\n          tokens.push(attributeSelector);\n          break;\n        }\n      case 58 /* Colon */:\n        {\n          if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {\n            tokens.push({\n              type: SelectorType.PseudoElement,\n              name: getName(2).toLowerCase(),\n              data: selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */ ? readValueWithParenthesis() : null\n            });\n            continue;\n          }\n          const name = getName(1).toLowerCase();\n          let data = null;\n          if (selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */) {\n            if (unpackPseudos.has(name)) {\n              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\n                throw new Error(`Pseudo-selector ${name} cannot be quoted`);\n              }\n              data = [];\n              selectorIndex = parseSelector(data, selector, selectorIndex + 1);\n              if (selector.charCodeAt(selectorIndex) !== 41 /* RightParenthesis */) {\n                throw new Error(`Missing closing parenthesis in :${name} (${selector})`);\n              }\n              selectorIndex += 1;\n            } else {\n              data = readValueWithParenthesis();\n              if (stripQuotesFromPseudos.has(name)) {\n                const quot = data.charCodeAt(0);\n                if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {\n                  data = data.slice(1, -1);\n                }\n              }\n              data = unescapeCSS(data);\n            }\n          }\n          tokens.push({\n            type: SelectorType.Pseudo,\n            name,\n            data\n          });\n          break;\n        }\n      case 44 /* Comma */:\n        {\n          finalizeSubselector();\n          tokens = [];\n          stripWhitespace(1);\n          break;\n        }\n      default:\n        {\n          if (selector.startsWith(\"/*\", selectorIndex)) {\n            const endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\n            if (endIndex < 0) {\n              throw new Error(\"Comment was not terminated\");\n            }\n            selectorIndex = endIndex + 2;\n            // Remove leading whitespace\n            if (tokens.length === 0) {\n              stripWhitespace(0);\n            }\n            break;\n          }\n          let namespace = null;\n          let name;\n          if (firstChar === 42 /* Asterisk */) {\n            selectorIndex += 1;\n            name = \"*\";\n          } else if (firstChar === 124 /* Pipe */) {\n            name = \"\";\n            if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {\n              addTraversal(SelectorType.ColumnCombinator);\n              stripWhitespace(2);\n              break;\n            }\n          } else if (reName.test(selector.slice(selectorIndex))) {\n            name = getName(0);\n          } else {\n            break loop;\n          }\n          if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ && selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {\n            namespace = name;\n            if (selector.charCodeAt(selectorIndex + 1) === 42 /* Asterisk */) {\n              name = \"*\";\n              selectorIndex += 2;\n            } else {\n              name = getName(1);\n            }\n          }\n          tokens.push(name === \"*\" ? {\n            type: SelectorType.Universal,\n            namespace\n          } : {\n            type: SelectorType.Tag,\n            name,\n            namespace\n          });\n        }\n    }\n  }\n  finalizeSubselector();\n  return selectorIndex;\n}","map":{"version":3,"names":["SelectorType","AttributeAction","reName","reEscape","actionTypes","Map","Element","Start","End","Any","Not","Hyphen","unpackPseudos","Set","isTraversal","selector","type","Adjacent","Child","Descendant","Parent","Sibling","ColumnCombinator","stripQuotesFromPseudos","funescape","_","escaped","escapedWhitespace","high","parseInt","String","fromCharCode","unescapeCSS","str","replace","isQuote","c","isWhitespace","parse","subselects","endIndex","parseSelector","length","Error","slice","selectorIndex","tokens","getName","offset","match","name","stripWhitespace","charCodeAt","readValueWithParenthesis","start","counter","isEscaped","pos","slashCount","ensureNotTraversal","addTraversal","push","addSpecialAttribute","action","Attribute","value","namespace","ignoreCase","finalizeSubselector","pop","loop","firstChar","Equals","startsWith","Exists","possibleAction","get","quote","sectionEnd","valueStart","forceIgnore","attributeSelector","PseudoElement","toLowerCase","data","has","quot","Pseudo","indexOf","test","Universal","Tag"],"sources":["D:/Work/V-Book/project/V-Book-Project/frontend/node_modules/css-what/lib/es/parse.js"],"sourcesContent":["import { SelectorType, AttributeAction, } from \"./types\";\r\nconst reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\r\nconst reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\r\nconst actionTypes = new Map([\r\n    [126 /* Tilde */, AttributeAction.Element],\r\n    [94 /* Circumflex */, AttributeAction.Start],\r\n    [36 /* Dollar */, AttributeAction.End],\r\n    [42 /* Asterisk */, AttributeAction.Any],\r\n    [33 /* ExclamationMark */, AttributeAction.Not],\r\n    [124 /* Pipe */, AttributeAction.Hyphen],\r\n]);\r\n// Pseudos, whose data property is parsed as well.\r\nconst unpackPseudos = new Set([\r\n    \"has\",\r\n    \"not\",\r\n    \"matches\",\r\n    \"is\",\r\n    \"where\",\r\n    \"host\",\r\n    \"host-context\",\r\n]);\r\n/**\r\n * Checks whether a specific selector is a traversal.\r\n * This is useful eg. in swapping the order of elements that\r\n * are not traversals.\r\n *\r\n * @param selector Selector to check.\r\n */\r\nexport function isTraversal(selector) {\r\n    switch (selector.type) {\r\n        case SelectorType.Adjacent:\r\n        case SelectorType.Child:\r\n        case SelectorType.Descendant:\r\n        case SelectorType.Parent:\r\n        case SelectorType.Sibling:\r\n        case SelectorType.ColumnCombinator:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nconst stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]);\r\n// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\r\nfunction funescape(_, escaped, escapedWhitespace) {\r\n    const high = parseInt(escaped, 16) - 0x10000;\r\n    // NaN means non-codepoint\r\n    return high !== high || escapedWhitespace\r\n        ? escaped\r\n        : high < 0\r\n            ? // BMP codepoint\r\n                String.fromCharCode(high + 0x10000)\r\n            : // Supplemental Plane codepoint (surrogate pair)\r\n                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\r\n}\r\nfunction unescapeCSS(str) {\r\n    return str.replace(reEscape, funescape);\r\n}\r\nfunction isQuote(c) {\r\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\r\n}\r\nfunction isWhitespace(c) {\r\n    return (c === 32 /* Space */ ||\r\n        c === 9 /* Tab */ ||\r\n        c === 10 /* NewLine */ ||\r\n        c === 12 /* FormFeed */ ||\r\n        c === 13 /* CarriageReturn */);\r\n}\r\n/**\r\n * Parses `selector`, optionally with the passed `options`.\r\n *\r\n * @param selector Selector to parse.\r\n * @param options Options for parsing.\r\n * @returns Returns a two-dimensional array.\r\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\r\n * the second contains the relevant tokens for that selector.\r\n */\r\nexport function parse(selector) {\r\n    const subselects = [];\r\n    const endIndex = parseSelector(subselects, `${selector}`, 0);\r\n    if (endIndex < selector.length) {\r\n        throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);\r\n    }\r\n    return subselects;\r\n}\r\nfunction parseSelector(subselects, selector, selectorIndex) {\r\n    let tokens = [];\r\n    function getName(offset) {\r\n        const match = selector.slice(selectorIndex + offset).match(reName);\r\n        if (!match) {\r\n            throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);\r\n        }\r\n        const [name] = match;\r\n        selectorIndex += offset + name.length;\r\n        return unescapeCSS(name);\r\n    }\r\n    function stripWhitespace(offset) {\r\n        selectorIndex += offset;\r\n        while (selectorIndex < selector.length &&\r\n            isWhitespace(selector.charCodeAt(selectorIndex))) {\r\n            selectorIndex++;\r\n        }\r\n    }\r\n    function readValueWithParenthesis() {\r\n        selectorIndex += 1;\r\n        const start = selectorIndex;\r\n        let counter = 1;\r\n        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\r\n            if (selector.charCodeAt(selectorIndex) ===\r\n                40 /* LeftParenthesis */ &&\r\n                !isEscaped(selectorIndex)) {\r\n                counter++;\r\n            }\r\n            else if (selector.charCodeAt(selectorIndex) ===\r\n                41 /* RightParenthesis */ &&\r\n                !isEscaped(selectorIndex)) {\r\n                counter--;\r\n            }\r\n        }\r\n        if (counter) {\r\n            throw new Error(\"Parenthesis not matched\");\r\n        }\r\n        return unescapeCSS(selector.slice(start, selectorIndex - 1));\r\n    }\r\n    function isEscaped(pos) {\r\n        let slashCount = 0;\r\n        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)\r\n            slashCount++;\r\n        return (slashCount & 1) === 1;\r\n    }\r\n    function ensureNotTraversal() {\r\n        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\r\n            throw new Error(\"Did not expect successive traversals.\");\r\n        }\r\n    }\r\n    function addTraversal(type) {\r\n        if (tokens.length > 0 &&\r\n            tokens[tokens.length - 1].type === SelectorType.Descendant) {\r\n            tokens[tokens.length - 1].type = type;\r\n            return;\r\n        }\r\n        ensureNotTraversal();\r\n        tokens.push({ type });\r\n    }\r\n    function addSpecialAttribute(name, action) {\r\n        tokens.push({\r\n            type: SelectorType.Attribute,\r\n            name,\r\n            action,\r\n            value: getName(1),\r\n            namespace: null,\r\n            ignoreCase: \"quirks\",\r\n        });\r\n    }\r\n    /**\r\n     * We have finished parsing the current part of the selector.\r\n     *\r\n     * Remove descendant tokens at the end if they exist,\r\n     * and return the last index, so that parsing can be\r\n     * picked up from here.\r\n     */\r\n    function finalizeSubselector() {\r\n        if (tokens.length &&\r\n            tokens[tokens.length - 1].type === SelectorType.Descendant) {\r\n            tokens.pop();\r\n        }\r\n        if (tokens.length === 0) {\r\n            throw new Error(\"Empty sub-selector\");\r\n        }\r\n        subselects.push(tokens);\r\n    }\r\n    stripWhitespace(0);\r\n    if (selector.length === selectorIndex) {\r\n        return selectorIndex;\r\n    }\r\n    loop: while (selectorIndex < selector.length) {\r\n        const firstChar = selector.charCodeAt(selectorIndex);\r\n        switch (firstChar) {\r\n            // Whitespace\r\n            case 32 /* Space */:\r\n            case 9 /* Tab */:\r\n            case 10 /* NewLine */:\r\n            case 12 /* FormFeed */:\r\n            case 13 /* CarriageReturn */: {\r\n                if (tokens.length === 0 ||\r\n                    tokens[0].type !== SelectorType.Descendant) {\r\n                    ensureNotTraversal();\r\n                    tokens.push({ type: SelectorType.Descendant });\r\n                }\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            // Traversals\r\n            case 62 /* GreaterThan */: {\r\n                addTraversal(SelectorType.Child);\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            case 60 /* LessThan */: {\r\n                addTraversal(SelectorType.Parent);\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            case 126 /* Tilde */: {\r\n                addTraversal(SelectorType.Sibling);\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            case 43 /* Plus */: {\r\n                addTraversal(SelectorType.Adjacent);\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            // Special attribute selectors: .class, #id\r\n            case 46 /* Period */: {\r\n                addSpecialAttribute(\"class\", AttributeAction.Element);\r\n                break;\r\n            }\r\n            case 35 /* Hash */: {\r\n                addSpecialAttribute(\"id\", AttributeAction.Equals);\r\n                break;\r\n            }\r\n            case 91 /* LeftSquareBracket */: {\r\n                stripWhitespace(1);\r\n                // Determine attribute name and namespace\r\n                let name;\r\n                let namespace = null;\r\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {\r\n                    // Equivalent to no namespace\r\n                    name = getName(1);\r\n                }\r\n                else if (selector.startsWith(\"*|\", selectorIndex)) {\r\n                    namespace = \"*\";\r\n                    name = getName(2);\r\n                }\r\n                else {\r\n                    name = getName(0);\r\n                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\r\n                        selector.charCodeAt(selectorIndex + 1) !==\r\n                            61 /* Equal */) {\r\n                        namespace = name;\r\n                        name = getName(1);\r\n                    }\r\n                }\r\n                stripWhitespace(0);\r\n                // Determine comparison operation\r\n                let action = AttributeAction.Exists;\r\n                const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\r\n                if (possibleAction) {\r\n                    action = possibleAction;\r\n                    if (selector.charCodeAt(selectorIndex + 1) !==\r\n                        61 /* Equal */) {\r\n                        throw new Error(\"Expected `=`\");\r\n                    }\r\n                    stripWhitespace(2);\r\n                }\r\n                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {\r\n                    action = AttributeAction.Equals;\r\n                    stripWhitespace(1);\r\n                }\r\n                // Determine value\r\n                let value = \"\";\r\n                let ignoreCase = null;\r\n                if (action !== \"exists\") {\r\n                    if (isQuote(selector.charCodeAt(selectorIndex))) {\r\n                        const quote = selector.charCodeAt(selectorIndex);\r\n                        let sectionEnd = selectorIndex + 1;\r\n                        while (sectionEnd < selector.length &&\r\n                            (selector.charCodeAt(sectionEnd) !== quote ||\r\n                                isEscaped(sectionEnd))) {\r\n                            sectionEnd += 1;\r\n                        }\r\n                        if (selector.charCodeAt(sectionEnd) !== quote) {\r\n                            throw new Error(\"Attribute value didn't end\");\r\n                        }\r\n                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\r\n                        selectorIndex = sectionEnd + 1;\r\n                    }\r\n                    else {\r\n                        const valueStart = selectorIndex;\r\n                        while (selectorIndex < selector.length &&\r\n                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&\r\n                                selector.charCodeAt(selectorIndex) !==\r\n                                    93 /* RightSquareBracket */) ||\r\n                                isEscaped(selectorIndex))) {\r\n                            selectorIndex += 1;\r\n                        }\r\n                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));\r\n                    }\r\n                    stripWhitespace(0);\r\n                    // See if we have a force ignore flag\r\n                    const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;\r\n                    // If the forceIgnore flag is set (either `i` or `s`), use that value\r\n                    if (forceIgnore === 115 /* LowerS */) {\r\n                        ignoreCase = false;\r\n                        stripWhitespace(1);\r\n                    }\r\n                    else if (forceIgnore === 105 /* LowerI */) {\r\n                        ignoreCase = true;\r\n                        stripWhitespace(1);\r\n                    }\r\n                }\r\n                if (selector.charCodeAt(selectorIndex) !==\r\n                    93 /* RightSquareBracket */) {\r\n                    throw new Error(\"Attribute selector didn't terminate\");\r\n                }\r\n                selectorIndex += 1;\r\n                const attributeSelector = {\r\n                    type: SelectorType.Attribute,\r\n                    name,\r\n                    action,\r\n                    value,\r\n                    namespace,\r\n                    ignoreCase,\r\n                };\r\n                tokens.push(attributeSelector);\r\n                break;\r\n            }\r\n            case 58 /* Colon */: {\r\n                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {\r\n                    tokens.push({\r\n                        type: SelectorType.PseudoElement,\r\n                        name: getName(2).toLowerCase(),\r\n                        data: selector.charCodeAt(selectorIndex) ===\r\n                            40 /* LeftParenthesis */\r\n                            ? readValueWithParenthesis()\r\n                            : null,\r\n                    });\r\n                    continue;\r\n                }\r\n                const name = getName(1).toLowerCase();\r\n                let data = null;\r\n                if (selector.charCodeAt(selectorIndex) ===\r\n                    40 /* LeftParenthesis */) {\r\n                    if (unpackPseudos.has(name)) {\r\n                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\r\n                            throw new Error(`Pseudo-selector ${name} cannot be quoted`);\r\n                        }\r\n                        data = [];\r\n                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);\r\n                        if (selector.charCodeAt(selectorIndex) !==\r\n                            41 /* RightParenthesis */) {\r\n                            throw new Error(`Missing closing parenthesis in :${name} (${selector})`);\r\n                        }\r\n                        selectorIndex += 1;\r\n                    }\r\n                    else {\r\n                        data = readValueWithParenthesis();\r\n                        if (stripQuotesFromPseudos.has(name)) {\r\n                            const quot = data.charCodeAt(0);\r\n                            if (quot === data.charCodeAt(data.length - 1) &&\r\n                                isQuote(quot)) {\r\n                                data = data.slice(1, -1);\r\n                            }\r\n                        }\r\n                        data = unescapeCSS(data);\r\n                    }\r\n                }\r\n                tokens.push({ type: SelectorType.Pseudo, name, data });\r\n                break;\r\n            }\r\n            case 44 /* Comma */: {\r\n                finalizeSubselector();\r\n                tokens = [];\r\n                stripWhitespace(1);\r\n                break;\r\n            }\r\n            default: {\r\n                if (selector.startsWith(\"/*\", selectorIndex)) {\r\n                    const endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\r\n                    if (endIndex < 0) {\r\n                        throw new Error(\"Comment was not terminated\");\r\n                    }\r\n                    selectorIndex = endIndex + 2;\r\n                    // Remove leading whitespace\r\n                    if (tokens.length === 0) {\r\n                        stripWhitespace(0);\r\n                    }\r\n                    break;\r\n                }\r\n                let namespace = null;\r\n                let name;\r\n                if (firstChar === 42 /* Asterisk */) {\r\n                    selectorIndex += 1;\r\n                    name = \"*\";\r\n                }\r\n                else if (firstChar === 124 /* Pipe */) {\r\n                    name = \"\";\r\n                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {\r\n                        addTraversal(SelectorType.ColumnCombinator);\r\n                        stripWhitespace(2);\r\n                        break;\r\n                    }\r\n                }\r\n                else if (reName.test(selector.slice(selectorIndex))) {\r\n                    name = getName(0);\r\n                }\r\n                else {\r\n                    break loop;\r\n                }\r\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\r\n                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {\r\n                    namespace = name;\r\n                    if (selector.charCodeAt(selectorIndex + 1) ===\r\n                        42 /* Asterisk */) {\r\n                        name = \"*\";\r\n                        selectorIndex += 2;\r\n                    }\r\n                    else {\r\n                        name = getName(1);\r\n                    }\r\n                }\r\n                tokens.push(name === \"*\"\r\n                    ? { type: SelectorType.Universal, namespace }\r\n                    : { type: SelectorType.Tag, name, namespace });\r\n            }\r\n        }\r\n    }\r\n    finalizeSubselector();\r\n    return selectorIndex;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}