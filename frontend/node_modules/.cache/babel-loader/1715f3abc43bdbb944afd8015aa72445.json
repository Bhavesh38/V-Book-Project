{"ast":null,"code":"import { hasChildren } from \"domhandler\";\n/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @category Helpers\n * @param nodes Nodes to filter.\n * @returns Remaining nodes that aren't subtrees of each other.\n */\nexport function removeSubsets(nodes) {\n  let idx = nodes.length;\n  /*\n   * Check if each node (or one of its ancestors) is already contained in the\n   * array.\n   */\n  while (--idx >= 0) {\n    const node = nodes[idx];\n    /*\n     * Remove the node if it is not unique.\n     * We are going through the array from the end, so we only\n     * have to check nodes that preceed the node under consideration in the array.\n     */\n    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n      nodes.splice(idx, 1);\n      continue;\n    }\n    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n      if (nodes.includes(ancestor)) {\n        nodes.splice(idx, 1);\n        break;\n      }\n    }\n  }\n  return nodes;\n}\n/**\n * @category Helpers\n * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}\n */\nexport var DocumentPosition;\n(function (DocumentPosition) {\n  DocumentPosition[DocumentPosition[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  DocumentPosition[DocumentPosition[\"PRECEDING\"] = 2] = \"PRECEDING\";\n  DocumentPosition[DocumentPosition[\"FOLLOWING\"] = 4] = \"FOLLOWING\";\n  DocumentPosition[DocumentPosition[\"CONTAINS\"] = 8] = \"CONTAINS\";\n  DocumentPosition[DocumentPosition[\"CONTAINED_BY\"] = 16] = \"CONTAINED_BY\";\n})(DocumentPosition || (DocumentPosition = {}));\n/**\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the values from {@link DocumentPosition}.\n *\n * Document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent.\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n *\n * @category Helpers\n * @param nodeA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n * @returns A bitmask describing the input nodes' relative position.\n *\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n * a description of these values.\n */\nexport function compareDocumentPosition(nodeA, nodeB) {\n  const aParents = [];\n  const bParents = [];\n  if (nodeA === nodeB) {\n    return 0;\n  }\n  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;\n  while (current) {\n    aParents.unshift(current);\n    current = current.parent;\n  }\n  current = hasChildren(nodeB) ? nodeB : nodeB.parent;\n  while (current) {\n    bParents.unshift(current);\n    current = current.parent;\n  }\n  const maxIdx = Math.min(aParents.length, bParents.length);\n  let idx = 0;\n  while (idx < maxIdx && aParents[idx] === bParents[idx]) {\n    idx++;\n  }\n  if (idx === 0) {\n    return DocumentPosition.DISCONNECTED;\n  }\n  const sharedParent = aParents[idx - 1];\n  const siblings = sharedParent.children;\n  const aSibling = aParents[idx];\n  const bSibling = bParents[idx];\n  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n    if (sharedParent === nodeB) {\n      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;\n    }\n    return DocumentPosition.FOLLOWING;\n  }\n  if (sharedParent === nodeA) {\n    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;\n  }\n  return DocumentPosition.PRECEDING;\n}\n/**\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong to\n * the same document, sort order is unspecified.\n *\n * @category Helpers\n * @param nodes Array of DOM nodes.\n * @returns Collection of unique nodes, sorted in document order.\n */\nexport function uniqueSort(nodes) {\n  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));\n  nodes.sort((a, b) => {\n    const relative = compareDocumentPosition(a, b);\n    if (relative & DocumentPosition.PRECEDING) {\n      return -1;\n    } else if (relative & DocumentPosition.FOLLOWING) {\n      return 1;\n    }\n    return 0;\n  });\n  return nodes;\n}","map":{"version":3,"mappings":"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","names":["hasChildren","removeSubsets","nodes","idx","length","node","lastIndexOf","splice","ancestor","parent","includes","DocumentPosition","compareDocumentPosition","nodeA","nodeB","aParents","bParents","current","unshift","maxIdx","Math","min","DISCONNECTED","sharedParent","siblings","children","aSibling","bSibling","indexOf","FOLLOWING","CONTAINED_BY","PRECEDING","CONTAINS","uniqueSort","filter","i","arr","sort","a","b","relative"],"sourceRoot":"https://raw.githubusercontent.com/fb55/domutils/f7e357b5c210b6731c2a60e0b7b3cfaa1f96b706/src/","sources":["helpers.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}