{"ast":null,"code":"import htmlTrie from \"./generated/encode-html.js\";\nimport { xmlReplacer, getCodePoint } from \"./escape.js\";\nconst htmlReplacer = /[\\t\\n!-,./:-@[-`\\f{-}$\\x80-\\uFFFF]/g;\n/**\n * Encodes all characters in the input using HTML entities. This includes\n * characters that are valid ASCII characters in HTML documents, such as `#`.\n *\n * To get a more compact output, consider using the `encodeNonAsciiHTML`\n * function, which will only encode characters that are not valid in HTML\n * documents, as well as non-ASCII characters.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nexport function encodeHTML(data) {\n  return encodeHTMLTrieRe(htmlReplacer, data);\n}\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities. This function will not encode characters that\n * are valid in HTML documents, such as `#`.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nexport function encodeNonAsciiHTML(data) {\n  return encodeHTMLTrieRe(xmlReplacer, data);\n}\nfunction encodeHTMLTrieRe(regExp, str) {\n  let ret = \"\";\n  let lastIdx = 0;\n  let match;\n  while ((match = regExp.exec(str)) !== null) {\n    const i = match.index;\n    ret += str.substring(lastIdx, i);\n    const char = str.charCodeAt(i);\n    let next = htmlTrie.get(char);\n    if (typeof next === \"object\") {\n      // We are in a branch. Try to match the next char.\n      if (i + 1 < str.length) {\n        const nextChar = str.charCodeAt(i + 1);\n        const value = typeof next.n === \"number\" ? next.n === nextChar ? next.o : undefined : next.n.get(nextChar);\n        if (value !== undefined) {\n          ret += value;\n          lastIdx = regExp.lastIndex += 1;\n          continue;\n        }\n      }\n      next = next.v;\n    }\n    // We might have a tree node without a value; skip and use a numeric entitiy.\n    if (next !== undefined) {\n      ret += next;\n      lastIdx = i + 1;\n    } else {\n      const cp = getCodePoint(str, i);\n      ret += `&#x${cp.toString(16)};`;\n      // Increase by 1 if we have a surrogate pair\n      lastIdx = regExp.lastIndex += Number(cp !== char);\n    }\n  }\n  return ret + str.substr(lastIdx);\n}","map":{"version":3,"sources":["encode.ts"],"names":[],"mappings":"AAAA,OAAO,QAAQ,MAAM,4BAA4B;AACjD,SAAS,WAAW,EAAE,YAAY,QAAQ,aAAa;AAEvD,MAAM,YAAY,GAAG,qCAAqC;AAE1D;;;;;;;;;;AAUG;AACH,OAAM,SAAU,UAAU,CAAC,IAAY,EAAA;EACnC,OAAO,gBAAgB,CAAC,YAAY,EAAE,IAAI,CAAC;AAC/C;AACA;;;;;;;AAOG;AACH,OAAM,SAAU,kBAAkB,CAAC,IAAY,EAAA;EAC3C,OAAO,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAAC;AAC9C;AAEA,SAAS,gBAAgB,CAAC,MAAc,EAAE,GAAW,EAAA;EACjD,IAAI,GAAG,GAAG,EAAE;EACZ,IAAI,OAAO,GAAG,CAAC;EACf,IAAI,KAAK;EAET,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,IAAI,EAAE;IACxC,MAAM,CAAC,GAAG,KAAK,CAAC,KAAK;IACrB,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,CAAC;IAChC,MAAM,IAAI,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;IAC9B,IAAI,IAAI,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC;IAE7B,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;MAC1B;MACA,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE;QACpB,MAAM,QAAQ,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC;QACtC,MAAM,KAAK,GACP,OAAO,IAAI,CAAC,CAAC,KAAK,QAAQ,GACpB,IAAI,CAAC,CAAC,KAAK,QAAQ,GACf,IAAI,CAAC,CAAC,GACN,SAAS,GACb,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC;QAE9B,IAAI,KAAK,KAAK,SAAS,EAAE;UACrB,GAAG,IAAI,KAAK;UACZ,OAAO,GAAG,MAAM,CAAC,SAAS,IAAI,CAAC;UAC/B;QACH;MACJ;MAED,IAAI,GAAG,IAAI,CAAC,CAAC;IAChB;IAED;IACA,IAAI,IAAI,KAAK,SAAS,EAAE;MACpB,GAAG,IAAI,IAAI;MACX,OAAO,GAAG,CAAC,GAAG,CAAC;KAClB,MAAM;MACH,MAAM,EAAE,GAAG,YAAY,CAAC,GAAG,EAAE,CAAC,CAAC;MAC/B,GAAG,IAAI,MAAM,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG;MAC/B;MACA,OAAO,GAAG,MAAM,CAAC,SAAS,IAAI,MAAM,CAAC,EAAE,KAAK,IAAI,CAAC;IACpD;EACJ;EAED,OAAO,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC;AACpC","sourceRoot":"https://raw.githubusercontent.com/fb55/entities/867ac709ba482a56a98b7c35f49ca833c74dc193/src/","sourcesContent":["import htmlTrie from \"./generated/encode-html.js\";\nimport { xmlReplacer, getCodePoint } from \"./escape.js\";\nconst htmlReplacer = /[\\t\\n!-,./:-@[-`\\f{-}$\\x80-\\uFFFF]/g;\n/**\n * Encodes all characters in the input using HTML entities. This includes\n * characters that are valid ASCII characters in HTML documents, such as `#`.\n *\n * To get a more compact output, consider using the `encodeNonAsciiHTML`\n * function, which will only encode characters that are not valid in HTML\n * documents, as well as non-ASCII characters.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nexport function encodeHTML(data) {\n    return encodeHTMLTrieRe(htmlReplacer, data);\n}\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities. This function will not encode characters that\n * are valid in HTML documents, such as `#`.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nexport function encodeNonAsciiHTML(data) {\n    return encodeHTMLTrieRe(xmlReplacer, data);\n}\nfunction encodeHTMLTrieRe(regExp, str) {\n    let ret = \"\";\n    let lastIdx = 0;\n    let match;\n    while ((match = regExp.exec(str)) !== null) {\n        const i = match.index;\n        ret += str.substring(lastIdx, i);\n        const char = str.charCodeAt(i);\n        let next = htmlTrie.get(char);\n        if (typeof next === \"object\") {\n            // We are in a branch. Try to match the next char.\n            if (i + 1 < str.length) {\n                const nextChar = str.charCodeAt(i + 1);\n                const value = typeof next.n === \"number\"\n                    ? next.n === nextChar\n                        ? next.o\n                        : undefined\n                    : next.n.get(nextChar);\n                if (value !== undefined) {\n                    ret += value;\n                    lastIdx = regExp.lastIndex += 1;\n                    continue;\n                }\n            }\n            next = next.v;\n        }\n        // We might have a tree node without a value; skip and use a numeric entitiy.\n        if (next !== undefined) {\n            ret += next;\n            lastIdx = i + 1;\n        }\n        else {\n            const cp = getCodePoint(str, i);\n            ret += `&#x${cp.toString(16)};`;\n            // Increase by 1 if we have a surrogate pair\n            lastIdx = regExp.lastIndex += Number(cp !== char);\n        }\n    }\n    return ret + str.substr(lastIdx);\n}\n//# sourceMappingURL=encode.js.map"]},"metadata":{},"sourceType":"module"}