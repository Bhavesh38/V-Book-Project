{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport classNames from 'classnames';\nimport ResizeObserver from 'rc-resize-observer';\nimport omit from \"rc-util/es/omit\";\nimport React, { createRef, forwardRef, useContext } from 'react';\nimport { ConfigContext } from '../config-provider';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport useStyle from './style';\nimport { addObserveTarget, getFixedBottom, getFixedTop, getTargetRect, removeObserveTarget } from './utils';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\nlet Affix = /*#__PURE__*/function (_React$Component) {\n  _inherits(Affix, _React$Component);\n  var _super = _createSuper(Affix);\n  function Affix() {\n    var _this;\n    _classCallCheck(this, Affix);\n    _this = _super.apply(this, arguments);\n    _this.state = {\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null\n    };\n    _this.placeholderNodeRef = /*#__PURE__*/createRef();\n    _this.fixedNodeRef = /*#__PURE__*/createRef();\n    _this.getOffsetTop = () => {\n      const {\n        offsetBottom,\n        offsetTop\n      } = _this.props;\n      return offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop;\n    };\n    _this.getOffsetBottom = () => _this.props.offsetBottom;\n    // =================== Measure ===================\n    _this.measure = () => {\n      const {\n        status,\n        lastAffix\n      } = _this.state;\n      const {\n        onChange\n      } = _this.props;\n      const targetFunc = _this.getTargetFunc();\n      if (status !== AffixStatus.Prepare || !_this.fixedNodeRef.current || !_this.placeholderNodeRef.current || !targetFunc) {\n        return;\n      }\n      const offsetTop = _this.getOffsetTop();\n      const offsetBottom = _this.getOffsetBottom();\n      const targetNode = targetFunc();\n      if (!targetNode) {\n        return;\n      }\n      const newState = {\n        status: AffixStatus.None\n      };\n      const targetRect = getTargetRect(targetNode);\n      const placeholderReact = getTargetRect(_this.placeholderNodeRef.current);\n      const fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop);\n      const fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom);\n      if (placeholderReact.top === 0 && placeholderReact.left === 0 && placeholderReact.width === 0 && placeholderReact.height === 0) {\n        return;\n      }\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width,\n          height: placeholderReact.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width,\n          height: placeholderReact.height\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width,\n          height: placeholderReact.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width,\n          height: placeholderReact.height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (onChange && lastAffix !== newState.lastAffix) {\n        onChange(newState.lastAffix);\n      }\n      _this.setState(newState);\n    };\n    _this.prepareMeasure = () => {\n      // event param is used before. Keep compatible ts define here.\n      _this.setState({\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        const {\n          onTestUpdatePosition\n        } = _this.props;\n        onTestUpdatePosition === null || onTestUpdatePosition === void 0 ? void 0 : onTestUpdatePosition();\n      }\n    };\n    _this.updatePosition = throttleByAnimationFrame(() => {\n      _this.prepareMeasure();\n    });\n    _this.lazyUpdatePosition = throttleByAnimationFrame(() => {\n      const targetFunc = _this.getTargetFunc();\n      const {\n        affixStyle\n      } = _this.state;\n      // Check position change before measure to make Safari smooth\n      if (targetFunc && affixStyle) {\n        const offsetTop = _this.getOffsetTop();\n        const offsetBottom = _this.getOffsetBottom();\n        const targetNode = targetFunc();\n        if (targetNode && _this.placeholderNodeRef.current) {\n          const targetRect = getTargetRect(targetNode);\n          const placeholderReact = getTargetRect(_this.placeholderNodeRef.current);\n          const fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop);\n          const fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      _this.prepareMeasure();\n    });\n    return _this;\n  }\n  _createClass(Affix, [{\n    key: \"getTargetFunc\",\n    value: function getTargetFunc() {\n      const {\n        getTargetContainer\n      } = this.context;\n      const {\n        target\n      } = this.props;\n      if (target !== undefined) {\n        return target;\n      }\n      return getTargetContainer !== null && getTargetContainer !== void 0 ? getTargetContainer : getDefaultTarget;\n    }\n    // Event handler\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      const targetFunc = this.getTargetFunc();\n      if (targetFunc) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        this.timer = setTimeout(() => {\n          addObserveTarget(targetFunc(), this);\n          // Mock Event object.\n          this.updatePosition();\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      const {\n        prevTarget\n      } = this.state;\n      const targetFunc = this.getTargetFunc();\n      const newTarget = (targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc()) || null;\n      if (prevTarget !== newTarget) {\n        removeObserveTarget(this);\n        if (newTarget) {\n          addObserveTarget(newTarget, this);\n          // Mock Event object.\n          this.updatePosition();\n        }\n        // eslint-disable-next-line react/no-did-update-set-state\n        this.setState({\n          prevTarget: newTarget\n        });\n      }\n      if (prevProps.offsetTop !== this.props.offsetTop || prevProps.offsetBottom !== this.props.offsetBottom) {\n        this.updatePosition();\n      }\n      this.measure();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.timer) {\n        clearTimeout(this.timer);\n        this.timer = null;\n      }\n      removeObserveTarget(this);\n      this.updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      this.lazyUpdatePosition.cancel();\n    }\n    // =================== Render ===================\n  }, {\n    key: \"render\",\n    value: function render() {\n      const {\n        affixStyle,\n        placeholderStyle\n      } = this.state;\n      const {\n        affixPrefixCls,\n        rootClassName,\n        children\n      } = this.props;\n      const className = classNames(affixStyle && rootClassName, {\n        [affixPrefixCls]: !!affixStyle\n      });\n      let props = omit(this.props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'affixPrefixCls', 'rootClassName']);\n      // Omit this since `onTestUpdatePosition` only works on test.\n      if (process.env.NODE_ENV === 'test') {\n        props = omit(props, ['onTestUpdatePosition']);\n      }\n      return /*#__PURE__*/React.createElement(ResizeObserver, {\n        onResize: this.updatePosition\n      }, /*#__PURE__*/React.createElement(\"div\", Object.assign({}, props, {\n        ref: this.placeholderNodeRef\n      }), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n        style: placeholderStyle,\n        \"aria-hidden\": \"true\"\n      }), /*#__PURE__*/React.createElement(\"div\", {\n        className: className,\n        ref: this.fixedNodeRef,\n        style: affixStyle\n      }, /*#__PURE__*/React.createElement(ResizeObserver, {\n        onResize: this.updatePosition\n      }, children))));\n    }\n  }]);\n  return Affix;\n}(React.Component);\nAffix.contextType = ConfigContext;\nconst AffixFC = /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    prefixCls: customizePrefixCls,\n    rootClassName\n  } = props;\n  const {\n    getPrefixCls\n  } = useContext(ConfigContext);\n  const affixPrefixCls = getPrefixCls('affix', customizePrefixCls);\n  const [wrapSSR, hashId] = useStyle(affixPrefixCls);\n  const AffixProps = Object.assign(Object.assign({}, props), {\n    affixPrefixCls,\n    rootClassName: classNames(rootClassName, hashId)\n  });\n  return wrapSSR( /*#__PURE__*/React.createElement(Affix, Object.assign({}, AffixProps, {\n    ref: ref\n  })));\n});\nif (process.env.NODE_ENV !== 'production') {\n  AffixFC.displayName = 'Affix';\n}\nexport default AffixFC;","map":{"version":3,"names":["_classCallCheck","_createClass","_inherits","_createSuper","classNames","ResizeObserver","omit","React","createRef","forwardRef","useContext","ConfigContext","throttleByAnimationFrame","useStyle","addObserveTarget","getFixedBottom","getFixedTop","getTargetRect","removeObserveTarget","getDefaultTarget","window","AffixStatus","Affix","_React$Component","_super","_this","apply","arguments","state","status","None","lastAffix","prevTarget","placeholderNodeRef","fixedNodeRef","getOffsetTop","offsetBottom","offsetTop","props","undefined","getOffsetBottom","measure","onChange","targetFunc","getTargetFunc","Prepare","current","targetNode","newState","targetRect","placeholderReact","fixedTop","fixedBottom","top","left","width","height","affixStyle","position","placeholderStyle","bottom","setState","prepareMeasure","process","env","NODE_ENV","onTestUpdatePosition","updatePosition","lazyUpdatePosition","key","value","getTargetContainer","context","target","componentDidMount","timer","setTimeout","componentDidUpdate","prevProps","newTarget","componentWillUnmount","clearTimeout","cancel","render","affixPrefixCls","rootClassName","children","className","createElement","onResize","Object","assign","ref","style","Component","contextType","AffixFC","prefixCls","customizePrefixCls","getPrefixCls","wrapSSR","hashId","AffixProps","displayName"],"sources":["D:/Work/V-Book/project/V-Book-Project/frontend/node_modules/antd/es/affix/index.js"],"sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\r\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\r\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\r\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\r\nimport classNames from 'classnames';\r\nimport ResizeObserver from 'rc-resize-observer';\r\nimport omit from \"rc-util/es/omit\";\r\nimport React, { createRef, forwardRef, useContext } from 'react';\r\nimport { ConfigContext } from '../config-provider';\r\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\r\nimport useStyle from './style';\r\nimport { addObserveTarget, getFixedBottom, getFixedTop, getTargetRect, removeObserveTarget } from './utils';\r\nfunction getDefaultTarget() {\r\n  return typeof window !== 'undefined' ? window : null;\r\n}\r\nvar AffixStatus;\r\n(function (AffixStatus) {\r\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\r\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\r\n})(AffixStatus || (AffixStatus = {}));\r\nlet Affix = /*#__PURE__*/function (_React$Component) {\r\n  _inherits(Affix, _React$Component);\r\n  var _super = _createSuper(Affix);\r\n  function Affix() {\r\n    var _this;\r\n    _classCallCheck(this, Affix);\r\n    _this = _super.apply(this, arguments);\r\n    _this.state = {\r\n      status: AffixStatus.None,\r\n      lastAffix: false,\r\n      prevTarget: null\r\n    };\r\n    _this.placeholderNodeRef = /*#__PURE__*/createRef();\r\n    _this.fixedNodeRef = /*#__PURE__*/createRef();\r\n    _this.getOffsetTop = () => {\r\n      const {\r\n        offsetBottom,\r\n        offsetTop\r\n      } = _this.props;\r\n      return offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop;\r\n    };\r\n    _this.getOffsetBottom = () => _this.props.offsetBottom;\r\n    // =================== Measure ===================\r\n    _this.measure = () => {\r\n      const {\r\n        status,\r\n        lastAffix\r\n      } = _this.state;\r\n      const {\r\n        onChange\r\n      } = _this.props;\r\n      const targetFunc = _this.getTargetFunc();\r\n      if (status !== AffixStatus.Prepare || !_this.fixedNodeRef.current || !_this.placeholderNodeRef.current || !targetFunc) {\r\n        return;\r\n      }\r\n      const offsetTop = _this.getOffsetTop();\r\n      const offsetBottom = _this.getOffsetBottom();\r\n      const targetNode = targetFunc();\r\n      if (!targetNode) {\r\n        return;\r\n      }\r\n      const newState = {\r\n        status: AffixStatus.None\r\n      };\r\n      const targetRect = getTargetRect(targetNode);\r\n      const placeholderReact = getTargetRect(_this.placeholderNodeRef.current);\r\n      const fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop);\r\n      const fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom);\r\n      if (placeholderReact.top === 0 && placeholderReact.left === 0 && placeholderReact.width === 0 && placeholderReact.height === 0) {\r\n        return;\r\n      }\r\n      if (fixedTop !== undefined) {\r\n        newState.affixStyle = {\r\n          position: 'fixed',\r\n          top: fixedTop,\r\n          width: placeholderReact.width,\r\n          height: placeholderReact.height\r\n        };\r\n        newState.placeholderStyle = {\r\n          width: placeholderReact.width,\r\n          height: placeholderReact.height\r\n        };\r\n      } else if (fixedBottom !== undefined) {\r\n        newState.affixStyle = {\r\n          position: 'fixed',\r\n          bottom: fixedBottom,\r\n          width: placeholderReact.width,\r\n          height: placeholderReact.height\r\n        };\r\n        newState.placeholderStyle = {\r\n          width: placeholderReact.width,\r\n          height: placeholderReact.height\r\n        };\r\n      }\r\n      newState.lastAffix = !!newState.affixStyle;\r\n      if (onChange && lastAffix !== newState.lastAffix) {\r\n        onChange(newState.lastAffix);\r\n      }\r\n      _this.setState(newState);\r\n    };\r\n    _this.prepareMeasure = () => {\r\n      // event param is used before. Keep compatible ts define here.\r\n      _this.setState({\r\n        status: AffixStatus.Prepare,\r\n        affixStyle: undefined,\r\n        placeholderStyle: undefined\r\n      });\r\n      // Test if `updatePosition` called\r\n      if (process.env.NODE_ENV === 'test') {\r\n        const {\r\n          onTestUpdatePosition\r\n        } = _this.props;\r\n        onTestUpdatePosition === null || onTestUpdatePosition === void 0 ? void 0 : onTestUpdatePosition();\r\n      }\r\n    };\r\n    _this.updatePosition = throttleByAnimationFrame(() => {\r\n      _this.prepareMeasure();\r\n    });\r\n    _this.lazyUpdatePosition = throttleByAnimationFrame(() => {\r\n      const targetFunc = _this.getTargetFunc();\r\n      const {\r\n        affixStyle\r\n      } = _this.state;\r\n      // Check position change before measure to make Safari smooth\r\n      if (targetFunc && affixStyle) {\r\n        const offsetTop = _this.getOffsetTop();\r\n        const offsetBottom = _this.getOffsetBottom();\r\n        const targetNode = targetFunc();\r\n        if (targetNode && _this.placeholderNodeRef.current) {\r\n          const targetRect = getTargetRect(targetNode);\r\n          const placeholderReact = getTargetRect(_this.placeholderNodeRef.current);\r\n          const fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop);\r\n          const fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom);\r\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n      // Directly call prepare measure since it's already throttled.\r\n      _this.prepareMeasure();\r\n    });\r\n    return _this;\r\n  }\r\n  _createClass(Affix, [{\r\n    key: \"getTargetFunc\",\r\n    value: function getTargetFunc() {\r\n      const {\r\n        getTargetContainer\r\n      } = this.context;\r\n      const {\r\n        target\r\n      } = this.props;\r\n      if (target !== undefined) {\r\n        return target;\r\n      }\r\n      return getTargetContainer !== null && getTargetContainer !== void 0 ? getTargetContainer : getDefaultTarget;\r\n    }\r\n    // Event handler\r\n  }, {\r\n    key: \"componentDidMount\",\r\n    value: function componentDidMount() {\r\n      const targetFunc = this.getTargetFunc();\r\n      if (targetFunc) {\r\n        // [Legacy] Wait for parent component ref has its value.\r\n        // We should use target as directly element instead of function which makes element check hard.\r\n        this.timer = setTimeout(() => {\r\n          addObserveTarget(targetFunc(), this);\r\n          // Mock Event object.\r\n          this.updatePosition();\r\n        });\r\n      }\r\n    }\r\n  }, {\r\n    key: \"componentDidUpdate\",\r\n    value: function componentDidUpdate(prevProps) {\r\n      const {\r\n        prevTarget\r\n      } = this.state;\r\n      const targetFunc = this.getTargetFunc();\r\n      const newTarget = (targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc()) || null;\r\n      if (prevTarget !== newTarget) {\r\n        removeObserveTarget(this);\r\n        if (newTarget) {\r\n          addObserveTarget(newTarget, this);\r\n          // Mock Event object.\r\n          this.updatePosition();\r\n        }\r\n        // eslint-disable-next-line react/no-did-update-set-state\r\n        this.setState({\r\n          prevTarget: newTarget\r\n        });\r\n      }\r\n      if (prevProps.offsetTop !== this.props.offsetTop || prevProps.offsetBottom !== this.props.offsetBottom) {\r\n        this.updatePosition();\r\n      }\r\n      this.measure();\r\n    }\r\n  }, {\r\n    key: \"componentWillUnmount\",\r\n    value: function componentWillUnmount() {\r\n      if (this.timer) {\r\n        clearTimeout(this.timer);\r\n        this.timer = null;\r\n      }\r\n      removeObserveTarget(this);\r\n      this.updatePosition.cancel();\r\n      // https://github.com/ant-design/ant-design/issues/22683\r\n      this.lazyUpdatePosition.cancel();\r\n    }\r\n    // =================== Render ===================\r\n  }, {\r\n    key: \"render\",\r\n    value: function render() {\r\n      const {\r\n        affixStyle,\r\n        placeholderStyle\r\n      } = this.state;\r\n      const {\r\n        affixPrefixCls,\r\n        rootClassName,\r\n        children\r\n      } = this.props;\r\n      const className = classNames(affixStyle && rootClassName, {\r\n        [affixPrefixCls]: !!affixStyle\r\n      });\r\n      let props = omit(this.props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'affixPrefixCls', 'rootClassName']);\r\n      // Omit this since `onTestUpdatePosition` only works on test.\r\n      if (process.env.NODE_ENV === 'test') {\r\n        props = omit(props, ['onTestUpdatePosition']);\r\n      }\r\n      return /*#__PURE__*/React.createElement(ResizeObserver, {\r\n        onResize: this.updatePosition\r\n      }, /*#__PURE__*/React.createElement(\"div\", Object.assign({}, props, {\r\n        ref: this.placeholderNodeRef\r\n      }), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\r\n        style: placeholderStyle,\r\n        \"aria-hidden\": \"true\"\r\n      }), /*#__PURE__*/React.createElement(\"div\", {\r\n        className: className,\r\n        ref: this.fixedNodeRef,\r\n        style: affixStyle\r\n      }, /*#__PURE__*/React.createElement(ResizeObserver, {\r\n        onResize: this.updatePosition\r\n      }, children))));\r\n    }\r\n  }]);\r\n  return Affix;\r\n}(React.Component);\r\nAffix.contextType = ConfigContext;\r\nconst AffixFC = /*#__PURE__*/forwardRef((props, ref) => {\r\n  const {\r\n    prefixCls: customizePrefixCls,\r\n    rootClassName\r\n  } = props;\r\n  const {\r\n    getPrefixCls\r\n  } = useContext(ConfigContext);\r\n  const affixPrefixCls = getPrefixCls('affix', customizePrefixCls);\r\n  const [wrapSSR, hashId] = useStyle(affixPrefixCls);\r\n  const AffixProps = Object.assign(Object.assign({}, props), {\r\n    affixPrefixCls,\r\n    rootClassName: classNames(rootClassName, hashId)\r\n  });\r\n  return wrapSSR( /*#__PURE__*/React.createElement(Affix, Object.assign({}, AffixProps, {\r\n    ref: ref\r\n  })));\r\n});\r\nif (process.env.NODE_ENV !== 'production') {\r\n  AffixFC.displayName = 'Affix';\r\n}\r\nexport default AffixFC;"],"mappings":"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"},"metadata":{},"sourceType":"module"}